<!DOCTYPE html>
<html lang="en-US" class="">

<!-- Mirrored from 127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 22 Sep 2025 18:52:46 GMT -->
<!-- Added by HTTrack --><meta http-equiv="content-type" content="text/html;charset=UTF-8" /><!-- /Added by HTTrack -->
<head>
    <!-- Basics -->
    <title>cl::sycl::handler Class Reference - Reference - ComputeCpp™ Community Edition - Products - Codeplay Developer</title>
    <meta name="description" content="Read the 'cl::sycl::handler Class Reference' for ComputeCpp™ Community Edition 2.11.0 API reference." />
    <meta name="keywords" content="reference, api, computecpp, ce, community, sycl, free, dpc++" />
    <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />

    <!-- Open Graph -->
    <meta name="title" property="og:title" content="cl::sycl::handler Class Reference - Reference - ComputeCpp™ Community Edition - Products - Codeplay Developer" />
    <meta name="type" property="og:type" content="website" />
    <meta name="image" property="og:image" content="http://127.0.0.1/assets/img/og-header.png" />
    <meta name="url" property="og:url" content="http://127.0.0.1/" />
    <meta name="description" property="og:description" content="Read the 'cl::sycl::handler Class Reference' for ComputeCpp™ Community Edition 2.11.0 API reference." />

    <!-- Fonts -->
    <link href="http://127.0.0.1/assets/css/material.css"
          rel="stylesheet preload prefetch"
          as="style" />

    <!-- Fav icon -->
    <link rel="icon" type="image/png" href="http://127.0.0.1/favicon-96x96.png" sizes="96x96" />
    <link rel="icon" type="image/svg+xml" href="http://127.0.0.1/favicon.svg" />
    <link rel="shortcut icon" href="http://127.0.0.1/favicon.ico" />
    <link rel="apple-touch-icon" sizes="180x180" href="http://127.0.0.1/apple-touch-icon.png" />

    <link type="text/css"
          href="http://127.0.0.1/assets/css/responsive.css"
          rel="stylesheet"/>

    <script src="https://cdn.usefathom.com/script.js" data-site="XBWVDDFP" defer></script>

    <!-- Stylesheets -->
    <link type="text/css"
          href="http://127.0.0.1/assets/css/jquery.cookiepolicyprompt.css"
          rel="stylesheet preload prefetch"
          as="style"/>
    <link type="text/css"
          href="http://127.0.0.1/assets/css/jquery.popupdialog.css"
          rel="stylesheet preload prefetch"
          as="style"/>
    <link type="text/css"
          href="http://127.0.0.1/assets/css/dialogs.css"
          rel="stylesheet preload prefetch"
          as="style"/>
    <link type="text/css"
          href="http://127.0.0.1/assets/css/Pages/IndexPage.style.css"
          rel="stylesheet preload prefetch"
          as="style"/>
    <link type="text/css"
          href="http://127.0.0.1/assets/css/Pages/Guides/GuidePageLayout.style.css"
          rel="stylesheet preload prefetch"
          as="style"/>
    <link type="text/css"
          href="http://127.0.0.1/assets/css/Pages/Guides/GuidePageFormatting.style.css"
          rel="stylesheet preload prefetch"
          as="style"/>
    <link type="text/css"
          href="http://127.0.0.1/assets/css/Pages/Guides/GuidePage.style.css"
          rel="stylesheet preload prefetch"
          as="style"/>
    <link type="text/css"
          href="http://127.0.0.1/assets/css/Pages/Reference/ReferencePage.style.css"
          rel="stylesheet preload prefetch"
          as="style"/>
    <link type="text/css"
          href="http://127.0.0.1/assets/css/Pages/Products/ComputeCpp/ComputeCppShared.style.css"
          rel="stylesheet preload prefetch"
          as="style"/>

    <!-- Scripts -->
    <script src="http://127.0.0.1/assets/js/jquery-3.6.3.min.js"></script>
    <script src="http://127.0.0.1/assets/js/jquery.copyright.js"></script>
    <script src="http://127.0.0.1/assets/js/jquery.cookiepolicyprompt.js"></script>
    <script src="http://127.0.0.1/assets/js/jquery.popupdialog.js"></script>
    <script src="http://127.0.0.1/assets/js/Pages/IndexPage.script.js"></script>
    <script src="http://127.0.0.1/assets/js/highlight.min.js"></script>
    <script src="http://127.0.0.1/assets/js/Pages/Guides/jquery.headingsinfocus.js"></script>
    <script src="http://127.0.0.1/assets/js/Pages/Guides/togglebutton.js"></script>
    <script src="http://127.0.0.1/assets/js/Pages/Guides/jquery.resizable.js"></script>
    <script src="http://127.0.0.1/assets/js/Pages/Guides/GuidePage.script.js"></script>

    <script>
        document.querySelectorAll('link').forEach((el) => {this.onload=null;this.rel='stylesheet';});
    </script>
</head>
<body data-deprecated="1">

<!-- Header -->
<header>
    <nav class="main">
        <div>
            <a aria-label="Navigation Bar Logo" href="http://127.0.0.1/">
                <div id="codeplay-logo"></div>
            </a>
        </div>
        <div>
            <a title="Click to change production selection">
                <div>
                    <h2>Product</h2>
                    <h1>ComputeCpp™ Community Edition</h1>
                </div>
            </a>
        </div>
        <div>
            <ul>
                <li >
                    <a href="http://127.0.0.1/products/computecpp/ce/home/" >
                        <div>

                            <span class="icon material-icons">home</span>

                            <div>Home</div>
                        </div>
                    </a>
                </li>
                <li >
                    <a href="http://127.0.0.1/products/computecpp/ce/guides/" >
                        <div>

                            <span class="icon material-icons">menu_book</span>

                            <div>Guides</div>
                        </div>
                    </a>
                </li>
                <li  class="selected" >
                    <a href="http://127.0.0.1/products/computecpp/ce/api-reference/" >
                        <div>

                            <span class="icon material-icons">auto_stories</span>

                            <div>Reference</div>
                        </div>
                    </a>
                </li>
                <li >
                    <a href="http://127.0.0.1/products/computecpp/ce/download/" >
                        <div>

                            <span class="icon material-icons">cloud_download</span>

                            <div>Download</div>
                        </div>
                    </a>
                </li>
            </ul>
        </div>
        <div>
            <ul>
                <li>
                    <a href="http://127.0.0.1/support/" title="Get Support">
                        <span class="material-icons">help_outline</span>
                    </a>
                </li>
                <li>
                    <a id="burger"
                       title="Show Navigation Menu">
                        <span class="material-icons">menu</span>
                    </a>
                </li>
            </ul>
        </div>
    </nav>

    <!-- The burger menu, designed for mobile -->
    <div id="burger-menu">
        <ul>
            <li>
                <h1>ComputeCpp™ Menu</h1>
                <ul>
                    <li >
                        <a href="http://127.0.0.1/products/computecpp/ce/home/"
                           >Home</a>
                    </li>
                    <li >
                        <a href="http://127.0.0.1/products/computecpp/ce/guides/"
                           >Guides</a>
                    </li>
                    <li  class="selected" >
                        <a href="http://127.0.0.1/products/computecpp/ce/api-reference/"
                           >Reference</a>
                    </li>
                    <li >
                        <a href="http://127.0.0.1/products/computecpp/ce/download/"
                           >Download</a>
                    </li>
                </ul>
            </li>
            <li>
                <h1>Main Menu</h1>
                <ul>
                    <li>
                        <a href="http://127.0.0.1/">Home</a>
                    </li>
                    <li>
                        <h1>Products</h1>
                        <ul>
                            <li>
                                <a href="http://127.0.0.1/products/computecpp/ce/">ComputeCpp CE</a>
                            </li>
                            <li>
                                <a href="http://127.0.0.1/products/computecpp/pe/">ComputeCpp PE</a>
                            </li>
                            <li>
                                <a href="http://127.0.0.1/products/computesuitercar/ce/">ComputeSuite for R-Car CE</a>
                            </li>
                            <li>
                                <a href="http://127.0.0.1/products/computesuitercar/pe/">ComputeSuite for R-Car PE</a>
                            </li>
                        </ul>
                    </li>
                    <li>
                        <a href="http://127.0.0.1/cookies">Cookie Policy</a>
                    </li>
                    <li>
                        <a href="https://codeplay.com/support/contact">Contact Us</a>
                    </li>
                </ul>
            </li>
        </ul>
    </div>
</header>

<!-- Main element -->
<main>
    <section class="product-deprecated warning-banner" style="display: block;">
        <div class="wrapper">
            <div>
                <i class="material-icons">info</i> Please note that this product is now discontinued and product support has ceased. For more information, <a href="https://www.codeplay.com/portal/news/2023/07/07/the-future-of-computecpp" target="_blank" rel="noopener">please read the blog</a>
            </div>
            <div>
            </div>
        </div>
    </section>

    <!-- File Container -->
<div class="layout-content-with-side-menu layout-file">
    <!-- Side Menu -->
    <div class="sticky file-menu-container styled-scroller">
        <div class="nav-padding">
            <!-- Title & Version Selector -->
            <div class="header">
                <h1 class="file-container-title">
                    <span class="material-icons">menu_book</span>Reference
                </h1>
                <div>
                    <!-- Version Selector -->
                    <div class="version-selector disabled">
                        <div><span class="material-icons">history</span>2.11.0</div>
                    </div>
                </div>
            </div>
            <!-- Menu -->
            <ol class="file-menu">
                <li class="selected"><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/annotated" ><div class="icon"></div>Classes</a><ol><li class="selected"><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl" ><div class="icon"><span class="type-icon namespace">N</span></div>cl</a><ol><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl" ><div class="icon"><span class="type-icon namespace">N</span></div>sycl</a><ol></ol></li><li class="selected"><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/structstd_1_1hash_3_01cl_1_1sycl_1_1accessor_3_01elem_t_00_01k_dims_00_01k_mode_00_01k_target_00_01is_placeholder_01_4_01_4" ><div class="icon"><span class="type-icon struct">S</span></div>hash&lt; cl::sycl::accessor&lt; elemT, kDims, kMode, kTarget, isPlaceholder &gt; &gt;</a><ol><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl_1_1info" ><div class="icon"><span class="type-icon namespace">N</span></div>info</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl_1_1property" ><div class="icon"><span class="type-icon namespace">N</span></div>property</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1device__selector" ><div class="icon"><span class="type-icon class">C</span></div>device_selector</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1accessor_3_01elem_t_00_010_00_01k_mode_00_01access_1_1target_1_1local_00_01ac11e61964f98321fc59e3ba211b2ed571" ><div class="icon"><span class="type-icon class">C</span></div>accessor&lt; elemT, 0, kMode, access::target::local, access::placeholder::false_t &gt;</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1accessor_3_01elem_t_00_01k_dims_00_01k_mode_00_01access_1_1target_1_1host__im3fae02425bb246de40230cdf06cc52dd" ><div class="icon"><span class="type-icon class">C</span></div>accessor&lt; elemT, kDims, kMode, access::target::host_image, access::placeholder::false_t &gt;</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1accessor_3_01elem_t_00_01k_dims_00_01k_mode_00_01access_1_1target_1_1image_0099ace1af3eb9921dd135ee22871e171c" ><div class="icon"><span class="type-icon class">C</span></div>accessor&lt; elemT, kDims, kMode, access::target::image, access::placeholder::false_t &gt;</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1accessor_3_01elem_t_00_01k_dims_00_01k_mode_00_01access_1_1target_1_1local_00954080e79c4cab78cbdd7b7477d4a6dd" ><div class="icon"><span class="type-icon class">C</span></div>accessor&lt; elemT, kDims, kMode, access::target::local, access::placeholder::false_t &gt;</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1accessor__error" ><div class="icon"><span class="type-icon class">C</span></div>accessor_error</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/structcl_1_1sycl_1_1atomic" ><div class="icon"><span class="type-icon struct">S</span></div>atomic</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1backend__traits_3_01backend_1_1opencl_01_4" ><div class="icon"><span class="type-icon class">C</span></div>backend_traits&lt; backend::opencl &gt;</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1buffer_3_01const_01_t_00_01dims_00_01_allocator_t_01_4" ><div class="icon"><span class="type-icon class">C</span></div>buffer&lt; const T, dims, AllocatorT &gt;</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1context" ><div class="icon"><span class="type-icon class">C</span></div>context</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1default__selector" ><div class="icon"><span class="type-icon class">C</span></div>default_selector</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1device__error" ><div class="icon"><span class="type-icon class">C</span></div>device_error</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/structcl_1_1sycl_1_1device__type" ><div class="icon"><span class="type-icon struct">S</span></div>device_type</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1event" ><div class="icon"><span class="type-icon class">C</span></div>event</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1exception" ><div class="icon"><span class="type-icon class">C</span></div>exception</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1feature__not__supported" ><div class="icon"><span class="type-icon class">C</span></div>feature_not_supported</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1group" ><div class="icon"><span class="type-icon class">C</span></div>group</a><ol></ol></li><li class="selected focused"><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler" ><div class="icon"><span class="type-icon class">C</span></div>handler</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1id" ><div class="icon"><span class="type-icon class">C</span></div>id</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/structcl_1_1sycl_1_1info__convert_3_01cl__context_01_5_00_01context_01_4" ><div class="icon"><span class="type-icon struct">S</span></div>info_convert&lt; cl_context *, context &gt;</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/structcl_1_1sycl_1_1info__convert_3_01cl__platform__id_01_5_00_01platform_01_4" ><div class="icon"><span class="type-icon struct">S</span></div>info_convert&lt; cl_platform_id *, platform &gt;</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1intel__selector" ><div class="icon"><span class="type-icon class">C</span></div>intel_selector</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1invalid__parameter__error" ><div class="icon"><span class="type-icon class">C</span></div>invalid_parameter_error</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1kernel" ><div class="icon"><span class="type-icon class">C</span></div>kernel</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1link__program__error" ><div class="icon"><span class="type-icon class">C</span></div>link_program_error</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1multi__ptr" ><div class="icon"><span class="type-icon class">C</span></div>multi_ptr</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1multi__ptr_3_01void_00_01asp_01_4" ><div class="icon"><span class="type-icon class">C</span></div>multi_ptr&lt; void, asp &gt;</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1nd__range" ><div class="icon"><span class="type-icon class">C</span></div>nd_range</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1opencl__selector" ><div class="icon"><span class="type-icon class">C</span></div>opencl_selector</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1platform__error" ><div class="icon"><span class="type-icon class">C</span></div>platform_error</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1private__memory" ><div class="icon"><span class="type-icon class">C</span></div>private_memory</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1profiling__error" ><div class="icon"><span class="type-icon class">C</span></div>profiling_error</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1property__list" ><div class="icon"><span class="type-icon class">C</span></div>property_list</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1range" ><div class="icon"><span class="type-icon class">C</span></div>range</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1sampler" ><div class="icon"><span class="type-icon class">C</span></div>sampler</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/structcl_1_1sycl_1_1stream__vec" ><div class="icon"><span class="type-icon struct">S</span></div>stream_vec</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/structcl_1_1sycl_1_1stream__vec_3_012_00_01true_00_01element_t_00_01k_dimensions_01_4" ><div class="icon"><span class="type-icon struct">S</span></div>stream_vec&lt; 2, true, elementT, kDimensions &gt;</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/structcl_1_1sycl_1_1stream__vec_3_014_00_01true_00_01element_t_00_01k_dimensions_01_4" ><div class="icon"><span class="type-icon struct">S</span></div>stream_vec&lt; 4, true, elementT, kDimensions &gt;</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1swizzled__vec" ><div class="icon"><span class="type-icon class">C</span></div>swizzled_vec</a><ol></ol></li></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/structstd_1_1hash_3_01cl_1_1sycl_1_1context_01_4" ><div class="icon"><span class="type-icon struct">S</span></div>hash&lt; cl::sycl::context &gt;</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/structstd_1_1hash_3_01cl_1_1sycl_1_1event_01_4" ><div class="icon"><span class="type-icon struct">S</span></div>hash&lt; cl::sycl::event &gt;</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/structstd_1_1hash_3_01cl_1_1sycl_1_1kernel_01_4" ><div class="icon"><span class="type-icon struct">S</span></div>hash&lt; cl::sycl::kernel &gt;</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/structstd_1_1hash_3_01cl_1_1sycl_1_1program_01_4" ><div class="icon"><span class="type-icon struct">S</span></div>hash&lt; cl::sycl::program &gt;</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/structstd_1_1hash_3_01cl_1_1sycl_1_1sampler_01_4" ><div class="icon"><span class="type-icon struct">S</span></div>hash&lt; cl::sycl::sampler &gt;</a><ol></ol></li></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl_1_1codeplay" ><div class="icon"><span class="type-icon namespace">N</span></div>codeplay</a><ol><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl_1_1codeplay_1_1profiling" ><div class="icon"><span class="type-icon namespace">N</span></div>profiling</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl_1_1codeplay_1_1property" ><div class="icon"><span class="type-icon namespace">N</span></div>property</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1codeplay_1_1handler" ><div class="icon"><span class="type-icon class">C</span></div>handler</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1codeplay_1_1interop__handle" ><div class="icon"><span class="type-icon class">C</span></div>interop_handle</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/structcl_1_1sycl_1_1experimental_1_1maximum" ><div class="icon"><span class="type-icon struct">S</span></div>maximum</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/structcl_1_1sycl_1_1experimental_1_1maximum_3_01void_01_4" ><div class="icon"><span class="type-icon struct">S</span></div>maximum&lt; void &gt;</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/structcl_1_1sycl_1_1experimental_1_1minimum_3_01void_01_4" ><div class="icon"><span class="type-icon struct">S</span></div>minimum&lt; void &gt;</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1property_1_1no__init__impl" ><div class="icon"><span class="type-icon class">C</span></div>no_init_impl</a><ol></ol></li></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1codeplay_1_1profiling_1_1profiling__zone" ><div class="icon"><span class="type-icon class">C</span></div>profiling_zone</a><ol><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1codeplay_1_1property_1_1buffer_1_1host__access" ><div class="icon"><span class="type-icon class">C</span></div>host_access</a><ol></ol></li></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl_1_1codeplay_1_1property_1_1buffer" ><div class="icon"><span class="type-icon namespace">N</span></div>buffer</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1codeplay_1_1property_1_1buffer_1_1use__onchip__memory" ><div class="icon"><span class="type-icon class">C</span></div>use_onchip_memory</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1codeplay_1_1host__handler" ><div class="icon"><span class="type-icon class">C</span></div>host_handler</a><ol><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/structcl_1_1sycl_1_1experimental_1_1usm__allocator_1_1rebind" ><div class="icon"><span class="type-icon struct">S</span></div>rebind</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1property_1_1buffer_1_1context__bound" ><div class="icon"><span class="type-icon class">C</span></div>context_bound</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1property_1_1buffer_1_1use__mutex" ><div class="icon"><span class="type-icon class">C</span></div>use_mutex</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1property_1_1queue_1_1enable__profiling" ><div class="icon"><span class="type-icon class">C</span></div>enable_profiling</a><ol></ol></li></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl_1_1experimental" ><div class="icon"><span class="type-icon namespace">N</span></div>experimental</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/structcl_1_1sycl_1_1experimental_1_1sub__group" ><div class="icon"><span class="type-icon struct">S</span></div>sub_group</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/structcl_1_1sycl_1_1experimental_1_1minimum" ><div class="icon"><span class="type-icon struct">S</span></div>minimum</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1experimental_1_1usm__allocator" ><div class="icon"><span class="type-icon class">C</span></div>usm_allocator</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl_1_1ext" ><div class="icon"><span class="type-icon namespace">N</span></div>ext</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/structcl_1_1sycl_1_1info_1_1param__traits" ><div class="icon"><span class="type-icon struct">S</span></div>param_traits</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl_1_1property_1_1buffer" ><div class="icon"><span class="type-icon namespace">N</span></div>buffer</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1property_1_1buffer_1_1use__host__ptr" ><div class="icon"><span class="type-icon class">C</span></div>use_host_ptr</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl_1_1property_1_1queue" ><div class="icon"><span class="type-icon namespace">N</span></div>queue</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1property_1_1queue_1_1in__order__impl" ><div class="icon"><span class="type-icon class">C</span></div>in_order_impl</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1accelerator__selector" ><div class="icon"><span class="type-icon class">C</span></div>accelerator_selector</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1accessor" ><div class="icon"><span class="type-icon class">C</span></div>accessor</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1accessor_3_01elem_t_00_01k_dims_00_01k_mode_00_01access_1_1target_1_1host__buf15cbef5585a67b9df703426df07becd" ><div class="icon"><span class="type-icon class">C</span></div>accessor&lt; elemT, kDims, kMode, access::target::host_buffer, access::placeholder::false_t &gt;</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1accessor_3_01elem_t_00_01k_dims_00_01k_mode_00_01access_1_1target_1_1host__task_00_01_is_placeholder_01_4" ><div class="icon"><span class="type-icon class">C</span></div>accessor&lt; elemT, kDims, kMode, access::target::host_task, IsPlaceholder &gt;</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1accessor_3_01elem_t_00_01k_dims_00_01k_mode_00_01access_1_1target_1_1image__a20b2e286317ab4aba41c67020102515e" ><div class="icon"><span class="type-icon class">C</span></div>accessor&lt; elemT, kDims, kMode, access::target::image_array, access::placeholder::false_t &gt;</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1accessor_3_01elem_t_00_01k_dims_00_01k_mode_00_01access_1_1target_1_1subgroup76e943a636f7dfa8379be4ce805ab016" ><div class="icon"><span class="type-icon class">C</span></div>accessor&lt; elemT, kDims, kMode, access::target::subgroup_local, access::placeholder::false_t &gt;</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1amd__selector" ><div class="icon"><span class="type-icon class">C</span></div>amd_selector</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1backend__traits" ><div class="icon"><span class="type-icon class">C</span></div>backend_traits</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1buffer" ><div class="icon"><span class="type-icon class">C</span></div>buffer</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1compile__program__error" ><div class="icon"><span class="type-icon class">C</span></div>compile_program_error</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1cpu__selector" ><div class="icon"><span class="type-icon class">C</span></div>cpu_selector</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1device" ><div class="icon"><span class="type-icon class">C</span></div>device</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1device__event" ><div class="icon"><span class="type-icon class">C</span></div>device_event</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/structcl_1_1sycl_1_1elem" ><div class="icon"><span class="type-icon struct">S</span></div>elem</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1event__error" ><div class="icon"><span class="type-icon class">C</span></div>event_error</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1exception__list" ><div class="icon"><span class="type-icon class">C</span></div>exception_list</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1gpu__selector" ><div class="icon"><span class="type-icon class">C</span></div>gpu_selector</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1h__item" ><div class="icon"><span class="type-icon class">C</span></div>h_item</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1host__selector" ><div class="icon"><span class="type-icon class">C</span></div>host_selector</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1image" ><div class="icon"><span class="type-icon class">C</span></div>image</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/structcl_1_1sycl_1_1info__convert_3_01cl__device__id_01_5_00_01device_01_4" ><div class="icon"><span class="type-icon struct">S</span></div>info_convert&lt; cl_device_id *, device &gt;</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/structcl_1_1sycl_1_1info__convert_3_01size__t_01_5_00_01range_3_013_01_4_01_4" ><div class="icon"><span class="type-icon struct">S</span></div>info_convert&lt; size_t *, range&lt; 3 &gt; &gt;</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1invalid__object__error" ><div class="icon"><span class="type-icon class">C</span></div>invalid_object_error</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1item" ><div class="icon"><span class="type-icon class">C</span></div>item</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1kernel__error" ><div class="icon"><span class="type-icon class">C</span></div>kernel_error</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1memory__allocation__error" ><div class="icon"><span class="type-icon class">C</span></div>memory_allocation_error</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1multi__ptr_3_01const_01void_00_01asp_01_4" ><div class="icon"><span class="type-icon class">C</span></div>multi_ptr&lt; const void, asp &gt;</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1nd__item" ><div class="icon"><span class="type-icon class">C</span></div>nd_item</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1nd__range__error" ><div class="icon"><span class="type-icon class">C</span></div>nd_range_error</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1platform" ><div class="icon"><span class="type-icon class">C</span></div>platform</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1precision__manipulator" ><div class="icon"><span class="type-icon class">C</span></div>precision_manipulator</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler" ><div class="icon"><span class="type-icon class">C</span></div>handler::parallel_for_work_group</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1program" ><div class="icon"><span class="type-icon class">C</span></div>program</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1queue" ><div class="icon"><span class="type-icon class">C</span></div>queue</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1runtime__error" ><div class="icon"><span class="type-icon class">C</span></div>runtime_error</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1stream" ><div class="icon"><span class="type-icon class">C</span></div>stream</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/structcl_1_1sycl_1_1stream__vec_3_0116_00_01true_00_01element_t_00_01k_dimensions_01_4" ><div class="icon"><span class="type-icon struct">S</span></div>stream_vec&lt; 16, true, elementT, kDimensions &gt;</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/structcl_1_1sycl_1_1stream__vec_3_013_00_01true_00_01element_t_00_01k_dimensions_01_4" ><div class="icon"><span class="type-icon struct">S</span></div>stream_vec&lt; 3, true, elementT, kDimensions &gt;</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/structcl_1_1sycl_1_1stream__vec_3_018_00_01true_00_01element_t_00_01k_dimensions_01_4" ><div class="icon"><span class="type-icon struct">S</span></div>stream_vec&lt; 8, true, elementT, kDimensions &gt;</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1vec" ><div class="icon"><span class="type-icon class">C</span></div>vec</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/structstd_1_1hash_3_01cl_1_1sycl_1_1buffer_3_01_t_00_01dimensions_00_01_allocator_t_01_4_01_4" ><div class="icon"><span class="type-icon struct">S</span></div>hash&lt; cl::sycl::buffer&lt; T, dimensions, AllocatorT &gt; &gt;</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/structstd_1_1hash_3_01cl_1_1sycl_1_1device_01_4" ><div class="icon"><span class="type-icon struct">S</span></div>hash&lt; cl::sycl::device &gt;</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/structstd_1_1hash_3_01cl_1_1sycl_1_1image_3_01k_dimensions_00_01_allocator_t_01_4_01_4" ><div class="icon"><span class="type-icon struct">S</span></div>hash&lt; cl::sycl::image&lt; kDimensions, AllocatorT &gt; &gt;</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/structstd_1_1hash_3_01cl_1_1sycl_1_1platform_01_4" ><div class="icon"><span class="type-icon struct">S</span></div>hash&lt; cl::sycl::platform &gt;</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/structstd_1_1hash_3_01cl_1_1sycl_1_1queue_01_4" ><div class="icon"><span class="type-icon struct">S</span></div>hash&lt; cl::sycl::queue &gt;</a><ol></ol></li><li class=""><a  href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/structstd_1_1hash_3_01cl_1_1sycl_1_1stream_01_4" ><div class="icon"><span class="type-icon struct">S</span></div>hash&lt; cl::sycl::stream &gt;</a><ol></ol></li></ol></li>            </ol>
        </div>
    </div>
    <!-- Core Content -->
    <div>
        <!-- File Content -->
        <div id="content-container" class="nav-padding">
            <article class="file-content-container">
                <header>
                    <!-- Deprecated Notice -->

                    <h1>cl::sycl::handler Class Reference</h1>
                </header>
                <div class="formatted-text">
                    <a id="top"></a>
                    <html><body><div class="contents">
<p>A handler gives user access to command group scope functionality, such as API calls.  
 <a href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#details">More...</a></p>
<p><code>#include &lt;<a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html">apis.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ad13964683fae164ccba5eff3eccb557d"><td class="memItemLeft">COMPUTECPP_TEST_VIRTUAL </td><td class="memItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#ad13964683fae164ccba5eff3eccb557d">~handler</a> ()</td></tr>
<tr class="memdesc:ad13964683fae164ccba5eff3eccb557d"><td class="mdescLeft"> </td><td class="mdescRight">Destructor of the handler, implementation on the cpp file so the default_deleter can see the implementation of the internal transaction object.  <a href="#ad13964683fae164ccba5eff3eccb557d">More...</a><br></td></tr>
<tr class="separator:ad13964683fae164ccba5eff3eccb557d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac6dc2ba0c93e4fe63c9ad7a7cfad6ec8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac6dc2ba0c93e4fe63c9ad7a7cfad6ec8"><td class="memTemplItemLeft">void </td><td class="memTemplItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#ac6dc2ba0c93e4fe63c9ad7a7cfad6ec8">set_arg</a> (int param_num, T &amp;&amp;param)</td></tr>
<tr class="memdesc:ac6dc2ba0c93e4fe63c9ad7a7cfad6ec8"><td class="mdescLeft"> </td><td class="mdescRight">Sets an argument when using interop kernels.  <a href="#ac6dc2ba0c93e4fe63c9ad7a7cfad6ec8">More...</a><br></td></tr>
<tr class="separator:ac6dc2ba0c93e4fe63c9ad7a7cfad6ec8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a529b800f175828a7edc07b0d1a19a176"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a529b800f175828a7edc07b0d1a19a176"><td class="memTemplItemLeft">void </td><td class="memTemplItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#a529b800f175828a7edc07b0d1a19a176">set_args</a> (Ts &amp;&amp;... args)</td></tr>
<tr class="memdesc:a529b800f175828a7edc07b0d1a19a176"><td class="mdescLeft"> </td><td class="mdescRight">Set all the given kernel args arguments for an OpenCL kernel, as if <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#ac6dc2ba0c93e4fe63c9ad7a7cfad6ec8">set_arg()</a> was used with each of them in the same order and increasing index always starting at 0.  <a href="#a529b800f175828a7edc07b0d1a19a176">More...</a><br></td></tr>
<tr class="separator:a529b800f175828a7edc07b0d1a19a176"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a753a7db9214d40fb8d43ac6c8b6833e2"><td class="memItemLeft">void </td><td class="memItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#a753a7db9214d40fb8d43ac6c8b6833e2">single_task</a> (<a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1kernel.html">kernel</a> syclKernel)</td></tr>
<tr class="memdesc:a753a7db9214d40fb8d43ac6c8b6833e2"><td class="mdescLeft"> </td><td class="mdescRight">This function effectively just launches a single thread to execute the kernel in serial asynchronously to the host execution.  <a href="#a753a7db9214d40fb8d43ac6c8b6833e2">More...</a><br></td></tr>
<tr class="separator:a753a7db9214d40fb8d43ac6c8b6833e2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a91585b4494de2792a5dce6bfcd416bf9"><td class="memTemplParams" colspan="2">template&lt;typename nameT  = std::nullptr_t, typename functorT &gt; </td></tr>
<tr class="memitem:a91585b4494de2792a5dce6bfcd416bf9"><td class="memTemplItemLeft">void </td><td class="memTemplItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#a91585b4494de2792a5dce6bfcd416bf9">single_task</a> (const functorT &amp;<a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl.html#afd8687e935d3df6c3fdbbc249e467d0d">functor</a>)</td></tr>
<tr class="memdesc:a91585b4494de2792a5dce6bfcd416bf9"><td class="mdescLeft"> </td><td class="mdescRight">This function effectively just launches a single thread to execute the kernel in serial asynchronously to the host execution.  <a href="#a91585b4494de2792a5dce6bfcd416bf9">More...</a><br></td></tr>
<tr class="separator:a91585b4494de2792a5dce6bfcd416bf9"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a07d716116114414cd509a93ccd8dda33"><td class="memTemplParams" colspan="2">template&lt;typename nameT  = std::nullptr_t, typename functorT &gt; </td></tr>
<tr class="memitem:a07d716116114414cd509a93ccd8dda33"><td class="memTemplItemLeft">void </td><td class="memTemplItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#a07d716116114414cd509a93ccd8dda33">single_task</a> (<a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1kernel.html">kernel</a> syclKernel, const functorT &amp;<a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl.html#afd8687e935d3df6c3fdbbc249e467d0d">functor</a>)</td></tr>
<tr class="memdesc:a07d716116114414cd509a93ccd8dda33"><td class="mdescLeft"> </td><td class="mdescRight">This function effectively just launches a single thread to execute the kernel in serial asynchronously to the host execution.  <a href="#a07d716116114414cd509a93ccd8dda33">More...</a><br></td></tr>
<tr class="separator:a07d716116114414cd509a93ccd8dda33"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a547a65572de8083252b465ac1074dc43"><td class="memTemplParams" colspan="2">template&lt;int dimensions&gt; </td></tr>
<tr class="memitem:a547a65572de8083252b465ac1074dc43"><td class="memTemplItemLeft">void </td><td class="memTemplItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#a547a65572de8083252b465ac1074dc43">parallel_for</a> (const <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1nd__range.html">nd_range</a>&lt; dimensions &gt; &amp;ndRange, <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1kernel.html">kernel</a> syclKernel)</td></tr>
<tr class="memdesc:a547a65572de8083252b465ac1074dc43"><td class="mdescLeft"> </td><td class="mdescRight">Parallel_for will enqueue the precompiled kernel syclKernel to be executed a number of instances working in parallel over the number of local and global work items specified by ndRange.  <a href="#a547a65572de8083252b465ac1074dc43">More...</a><br></td></tr>
<tr class="separator:a547a65572de8083252b465ac1074dc43"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4ccd2c8e4deeb2edf901710d711b256b"><td class="memTemplParams" colspan="2">template&lt;int dimensions&gt; </td></tr>
<tr class="memitem:a4ccd2c8e4deeb2edf901710d711b256b"><td class="memTemplItemLeft">void </td><td class="memTemplItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#a4ccd2c8e4deeb2edf901710d711b256b">parallel_for</a> (const <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1range.html">range</a>&lt; dimensions &gt; &amp;<a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1range.html">range</a>, <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1kernel.html">kernel</a> syclKernel)</td></tr>
<tr class="memdesc:a4ccd2c8e4deeb2edf901710d711b256b"><td class="mdescLeft"> </td><td class="mdescRight">Parallel_for will enqueue the precompiled kernel syclKernel to be executed a number of instances working in parallel over the number of global work items specified by <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1range.html">range</a>.  <a href="#a4ccd2c8e4deeb2edf901710d711b256b">More...</a><br></td></tr>
<tr class="separator:a4ccd2c8e4deeb2edf901710d711b256b"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4579e9fef96e51ab64ac1e5d9dc4d9b7"><td class="memTemplParams" colspan="2">template&lt;int dimensions&gt; </td></tr>
<tr class="memitem:a4579e9fef96e51ab64ac1e5d9dc4d9b7"><td class="memTemplItemLeft">void </td><td class="memTemplItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#a4579e9fef96e51ab64ac1e5d9dc4d9b7">parallel_for</a> (const <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1range.html">range</a>&lt; dimensions &gt; &amp;<a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1range.html">range</a>, <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1id.html">id</a>&lt; dimensions &gt; offset, <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1kernel.html">kernel</a> syclKernel)</td></tr>
<tr class="memdesc:a4579e9fef96e51ab64ac1e5d9dc4d9b7"><td class="mdescLeft"> </td><td class="mdescRight">Parallel_for will enqueue the precompiled kernel syclKernel to be executed a number of instances working in parallel over the number of global work items specified by <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1range.html">range</a>.  <a href="#a4579e9fef96e51ab64ac1e5d9dc4d9b7">More...</a><br></td></tr>
<tr class="separator:a4579e9fef96e51ab64ac1e5d9dc4d9b7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac69072e1239801448dadf86e1b8542fe"><td class="memTemplParams" colspan="2">template&lt;typename nameT  = std::nullptr_t, typename functorT , int dimensions&gt; </td></tr>
<tr class="memitem:ac69072e1239801448dadf86e1b8542fe"><td class="memTemplItemLeft">void </td><td class="memTemplItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#ac69072e1239801448dadf86e1b8542fe">parallel_for</a> (const <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1nd__range.html">nd_range</a>&lt; dimensions &gt; &amp;ndRange, const functorT &amp;<a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl.html#afd8687e935d3df6c3fdbbc249e467d0d">functor</a>)</td></tr>
<tr class="memdesc:ac69072e1239801448dadf86e1b8542fe"><td class="mdescLeft"> </td><td class="mdescRight">Parallel_for will enqueue the kernel <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl.html#afd8687e935d3df6c3fdbbc249e467d0d">functor</a> to be executed a number of instances working in parallel over the number of local and global work items specified by ndRange.  <a href="#ac69072e1239801448dadf86e1b8542fe">More...</a><br></td></tr>
<tr class="separator:ac69072e1239801448dadf86e1b8542fe"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae0e010b69b66eb87a78d0f0291e6f87a"><td class="memTemplParams" colspan="2">template&lt;typename nameT  = std::nullptr_t, typename functorT , int dimensions&gt; </td></tr>
<tr class="memitem:ae0e010b69b66eb87a78d0f0291e6f87a"><td class="memTemplItemLeft">void </td><td class="memTemplItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#ae0e010b69b66eb87a78d0f0291e6f87a">parallel_for</a> (<a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1kernel.html">kernel</a> syclKernel, const <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1nd__range.html">nd_range</a>&lt; dimensions &gt; &amp;ndRange, const functorT &amp;<a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl.html#afd8687e935d3df6c3fdbbc249e467d0d">functor</a>)</td></tr>
<tr class="memdesc:ae0e010b69b66eb87a78d0f0291e6f87a"><td class="mdescLeft"> </td><td class="mdescRight">Parallel_for will enqueue the kernel <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl.html#afd8687e935d3df6c3fdbbc249e467d0d">functor</a> to be executed a number of instances working in parallel over the number of local and global work items specified by ndRange.  <a href="#ae0e010b69b66eb87a78d0f0291e6f87a">More...</a><br></td></tr>
<tr class="separator:ae0e010b69b66eb87a78d0f0291e6f87a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0914ce8c9f19a41918ab711d838b9d07"><td class="memTemplParams" colspan="2">template&lt;typename nameT  = std::nullptr_t, typename functorT , int dimensions&gt; </td></tr>
<tr class="memitem:a0914ce8c9f19a41918ab711d838b9d07"><td class="memTemplItemLeft">void </td><td class="memTemplItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#a0914ce8c9f19a41918ab711d838b9d07">parallel_for</a> (const <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1range.html">range</a>&lt; dimensions &gt; &amp;<a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1range.html">range</a>, const functorT &amp;<a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl.html#afd8687e935d3df6c3fdbbc249e467d0d">functor</a>)</td></tr>
<tr class="memdesc:a0914ce8c9f19a41918ab711d838b9d07"><td class="mdescLeft"> </td><td class="mdescRight">Parallel_for will enqueue the kernel <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl.html#afd8687e935d3df6c3fdbbc249e467d0d">functor</a> to be executed a number of instances working in parallel over the number of global work items specified by <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1range.html">range</a>.  <a href="#a0914ce8c9f19a41918ab711d838b9d07">More...</a><br></td></tr>
<tr class="separator:a0914ce8c9f19a41918ab711d838b9d07"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a58ba5230da79a8c4e2fec90ed366c885"><td class="memTemplParams" colspan="2">template&lt;typename nameT  = std::nullptr_t, typename functorT &gt; </td></tr>
<tr class="memitem:a58ba5230da79a8c4e2fec90ed366c885"><td class="memTemplItemLeft">void </td><td class="memTemplItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#a58ba5230da79a8c4e2fec90ed366c885">parallel_for</a> (const size_t <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1range.html">range</a>, const functorT &amp;<a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl.html#afd8687e935d3df6c3fdbbc249e467d0d">functor</a>)</td></tr>
<tr class="memdesc:a58ba5230da79a8c4e2fec90ed366c885"><td class="mdescLeft"> </td><td class="mdescRight">Parallel_for will enqueue the kernel <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl.html#afd8687e935d3df6c3fdbbc249e467d0d">functor</a> to be executed a number of instances working in parallel over the number of global work items specified by <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1range.html">range</a>.  <a href="#a58ba5230da79a8c4e2fec90ed366c885">More...</a><br></td></tr>
<tr class="separator:a58ba5230da79a8c4e2fec90ed366c885"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aec471f48e98c26efe4de1c80069a82ac"><td class="memTemplParams" colspan="2">template&lt;typename nameT  = std::nullptr_t, typename functorT , int dimensions&gt; </td></tr>
<tr class="memitem:aec471f48e98c26efe4de1c80069a82ac"><td class="memTemplItemLeft">void </td><td class="memTemplItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#aec471f48e98c26efe4de1c80069a82ac">parallel_for</a> (const <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1range.html">range</a>&lt; dimensions &gt; &amp;<a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1range.html">range</a>, const <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1id.html">id</a>&lt; dimensions &gt; &amp;offset, const functorT &amp;<a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl.html#afd8687e935d3df6c3fdbbc249e467d0d">functor</a>)</td></tr>
<tr class="memdesc:aec471f48e98c26efe4de1c80069a82ac"><td class="mdescLeft"> </td><td class="mdescRight">Parallel_for will enqueue the kernel <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl.html#afd8687e935d3df6c3fdbbc249e467d0d">functor</a> to be executed a number of instances working in parallel over the number of global work items specified by <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1range.html">range</a>.  <a href="#aec471f48e98c26efe4de1c80069a82ac">More...</a><br></td></tr>
<tr class="separator:aec471f48e98c26efe4de1c80069a82ac"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad026053d5411280844d6d8664abe9268"><td class="memTemplParams" colspan="2">template&lt;typename nameT  = std::nullptr_t, typename functorT , int dimensions&gt; </td></tr>
<tr class="memitem:ad026053d5411280844d6d8664abe9268"><td class="memTemplItemLeft">void </td><td class="memTemplItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#ad026053d5411280844d6d8664abe9268">parallel_for</a> (<a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1kernel.html">kernel</a> syclKernel, const <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1range.html">range</a>&lt; dimensions &gt; &amp;<a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1range.html">range</a>, const functorT &amp;<a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl.html#afd8687e935d3df6c3fdbbc249e467d0d">functor</a>)</td></tr>
<tr class="memdesc:ad026053d5411280844d6d8664abe9268"><td class="mdescLeft"> </td><td class="mdescRight">Parallel_for will enqueue the precompiled kernel syclKernel to be executed a number of instances working in parallel over the number of global work items specified by <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1range.html">range</a>.  <a href="#ad026053d5411280844d6d8664abe9268">More...</a><br></td></tr>
<tr class="separator:ad026053d5411280844d6d8664abe9268"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a4304deb0235543437d2026a9c4451929"><td class="memTemplParams" colspan="2">template&lt;typename nameT  = std::nullptr_t, typename functorT , int dimensions&gt; </td></tr>
<tr class="memitem:a4304deb0235543437d2026a9c4451929"><td class="memTemplItemLeft">void </td><td class="memTemplItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#a4304deb0235543437d2026a9c4451929">parallel_for</a> (<a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1kernel.html">kernel</a> syclKernel, const <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1range.html">range</a>&lt; dimensions &gt; &amp;<a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1range.html">range</a>, const <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1id.html">id</a>&lt; dimensions &gt; &amp;offset, const functorT &amp;<a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl.html#afd8687e935d3df6c3fdbbc249e467d0d">functor</a>)</td></tr>
<tr class="memdesc:a4304deb0235543437d2026a9c4451929"><td class="mdescLeft"> </td><td class="mdescRight">Parallel_for will enqueue the precompiled kernel syclKernel to be executed a number of instances working in parallel over the number of global work items specified by <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1range.html">range</a>.  <a href="#a4304deb0235543437d2026a9c4451929">More...</a><br></td></tr>
<tr class="separator:a4304deb0235543437d2026a9c4451929"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab77f0bc273b16ca90baeca132ffe2538"><td class="memTemplParams" colspan="2">template&lt;int dimensions&gt; </td></tr>
<tr class="memitem:ab77f0bc273b16ca90baeca132ffe2538"><td class="memTemplItemLeft">void </td><td class="memTemplItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#ab77f0bc273b16ca90baeca132ffe2538">parallel_for_work_group</a> (const <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1range.html">range</a>&lt; dimensions &gt; &amp;numGroups, <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1kernel.html">kernel</a> syclKernel)</td></tr>
<tr class="memdesc:ab77f0bc273b16ca90baeca132ffe2538"><td class="mdescLeft"> </td><td class="mdescRight">parallel_for_work_group will enqueue the precompiled kernel syclKernel to be executed a number of instances working in parallel over the number of local and global work items specified by numGroups.  <a href="#ab77f0bc273b16ca90baeca132ffe2538">More...</a><br></td></tr>
<tr class="separator:ab77f0bc273b16ca90baeca132ffe2538"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a635eddb1e72722967c0a40b2f723b3d2"><td class="memTemplParams" colspan="2">template&lt;typename nameT  = std::nullptr_t, typename functorT , int dimensions&gt; </td></tr>
<tr class="memitem:a635eddb1e72722967c0a40b2f723b3d2"><td class="memTemplItemLeft">void </td><td class="memTemplItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#a635eddb1e72722967c0a40b2f723b3d2">parallel_for_work_group</a> (<a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1kernel.html">kernel</a> syclKernel, const <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1range.html">range</a>&lt; dimensions &gt; &amp;<a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1range.html">range</a>, const functorT &amp;<a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl.html#afd8687e935d3df6c3fdbbc249e467d0d">functor</a>)</td></tr>
<tr class="memdesc:a635eddb1e72722967c0a40b2f723b3d2"><td class="mdescLeft"> </td><td class="mdescRight">parallel_for_work_group will enqueue the precompiled kernel syclKernel to be executed a number of instances working in parallel over the number of local and global work items specified by <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1range.html">range</a>.  <a href="#a635eddb1e72722967c0a40b2f723b3d2">More...</a><br></td></tr>
<tr class="separator:a635eddb1e72722967c0a40b2f723b3d2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ab7af811ef14f9e15c957f3abbfb8dc44"><td class="memTemplParams" colspan="2">template&lt;typename nameT  = std::nullptr_t, typename functorT , int dimensions&gt; </td></tr>
<tr class="memitem:ab7af811ef14f9e15c957f3abbfb8dc44"><td class="memTemplItemLeft">void </td><td class="memTemplItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#ab7af811ef14f9e15c957f3abbfb8dc44">parallel_for_work_group</a> (const <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1range.html">range</a>&lt; dimensions &gt; &amp;<a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1range.html">range</a>, const functorT &amp;<a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl.html#afd8687e935d3df6c3fdbbc249e467d0d">functor</a>)</td></tr>
<tr class="memdesc:ab7af811ef14f9e15c957f3abbfb8dc44"><td class="mdescLeft"> </td><td class="mdescRight">parallel_for_work_group will enqueue the kernel <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl.html#afd8687e935d3df6c3fdbbc249e467d0d">functor</a> to be executed a number of instances working in parallel over the number of local and global work items specified by <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1range.html">range</a>.  <a href="#ab7af811ef14f9e15c957f3abbfb8dc44">More...</a><br></td></tr>
<tr class="separator:ab7af811ef14f9e15c957f3abbfb8dc44"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8a5c5be38037f90b4d00c93ad32874d7"><td class="memTemplParams" colspan="2">template&lt;typename nameT  = std::nullptr_t, typename functorT , int dimensions&gt; </td></tr>
<tr class="memitem:a8a5c5be38037f90b4d00c93ad32874d7"><td class="memTemplItemLeft">void </td><td class="memTemplItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#a8a5c5be38037f90b4d00c93ad32874d7">parallel_for_work_group</a> (const <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1range.html">range</a>&lt; dimensions &gt; &amp;numGroups, const <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1range.html">range</a>&lt; dimensions &gt; &amp;groupSize, const functorT &amp;<a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl.html#afd8687e935d3df6c3fdbbc249e467d0d">functor</a>)</td></tr>
<tr class="memdesc:a8a5c5be38037f90b4d00c93ad32874d7"><td class="mdescLeft"> </td><td class="mdescRight">parallel_for_work_group will enqueue the precompiled kernel syclKernel to be executed a number of instances working in parallel over the number of local and global work items specified by numGroups and groupSize.  <a href="#a8a5c5be38037f90b4d00c93ad32874d7">More...</a><br></td></tr>
<tr class="separator:a8a5c5be38037f90b4d00c93ad32874d7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a59c4e92995e59422df1e2c8447bdba4f"><td class="memTemplParams" colspan="2">template&lt;typename nameT  = std::nullptr_t, typename functorT , int dimensions&gt; </td></tr>
<tr class="memitem:a59c4e92995e59422df1e2c8447bdba4f"><td class="memTemplItemLeft">void </td><td class="memTemplItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#a59c4e92995e59422df1e2c8447bdba4f">parallel_for_work_group</a> (<a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1kernel.html">kernel</a> syclKernel, const <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1range.html">range</a>&lt; dimensions &gt; &amp;numGroups, const <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1range.html">range</a>&lt; dimensions &gt; &amp;groupSize, const functorT &amp;<a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl.html#afd8687e935d3df6c3fdbbc249e467d0d">functor</a>)</td></tr>
<tr class="memdesc:a59c4e92995e59422df1e2c8447bdba4f"><td class="mdescLeft"> </td><td class="mdescRight">parallel_for_work_group will enqueue the precompiled kernel syclKernel to be executed a number of instances working in parallel over the number of local and global work items specified by numGroups and groupSize.  <a href="#a59c4e92995e59422df1e2c8447bdba4f">More...</a><br></td></tr>
<tr class="separator:a59c4e92995e59422df1e2c8447bdba4f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a953fb3a325258dc660a0c4f9bcce1a9f"><td class="memTemplParams" colspan="2">template&lt;typename elemT , int kDims, access::mode kMode, access::target kTarget, access::placeholder IsPlaceholder = access::placeholder::true_t&gt; </td></tr>
<tr class="memitem:a953fb3a325258dc660a0c4f9bcce1a9f"><td class="memTemplItemLeft">void </td><td class="memTemplItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#a953fb3a325258dc660a0c4f9bcce1a9f">require</a> (const <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; elemT, <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl.html#adee2e3bdfed43ffe0b7ef0ea737c5a4c">kDims</a>, <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl.html#af827bc05849ee05ae978679bca689c43">kMode</a>, <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl.html#af98dc56956ad4fc67c4c52fdfa32f860">kTarget</a>, IsPlaceholder &gt; &amp;<a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#aacaa7a26269cdb5e27ea8f221462580e">acc</a>)</td></tr>
<tr class="memdesc:a953fb3a325258dc660a0c4f9bcce1a9f"><td class="mdescLeft"> </td><td class="mdescRight">Function that registers a placeholder accessor with the handler.  <a href="#a953fb3a325258dc660a0c4f9bcce1a9f">More...</a><br></td></tr>
<tr class="separator:a953fb3a325258dc660a0c4f9bcce1a9f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0d529c9e8d35ee704a1584ac76336889"><td class="memTemplParams" colspan="2">template&lt;typename elemT , int kDims, access::mode kMode, access::placeholder isPlaceholder&gt; </td></tr>
<tr class="memitem:a0d529c9e8d35ee704a1584ac76336889"><td class="memTemplItemLeft">void </td><td class="memTemplItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#a0d529c9e8d35ee704a1584ac76336889">register_for_dma</a> (<a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; elemT, <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl.html#adee2e3bdfed43ffe0b7ef0ea737c5a4c">kDims</a>, <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl.html#af827bc05849ee05ae978679bca689c43">kMode</a>, <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/common_8h.html#a01c96dfd06d3493f3cec972d38f45156">COMPUTECPP_ACCESS_TARGET_DEVICE</a>, isPlaceholder &gt; &amp;<a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#aacaa7a26269cdb5e27ea8f221462580e">acc</a>, size_t stride)</td></tr>
<tr class="memdesc:a0d529c9e8d35ee704a1584ac76336889"><td class="mdescLeft"> </td><td class="mdescRight">Registers a global memory accessor for DMA transfer.  <a href="#a0d529c9e8d35ee704a1584ac76336889">More...</a><br></td></tr>
<tr class="separator:a0d529c9e8d35ee704a1584ac76336889"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a75f75115658c50f5a5398225241c1c76"><td class="memTemplParams" colspan="2">template&lt;typename elemT , int kDims, access::placeholder isPlaceholder&gt; </td></tr>
<tr class="memitem:a75f75115658c50f5a5398225241c1c76"><td class="memTemplItemLeft">void </td><td class="memTemplItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#a75f75115658c50f5a5398225241c1c76">register_for_dma</a> (<a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; elemT, <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl.html#adee2e3bdfed43ffe0b7ef0ea737c5a4c">kDims</a>, <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl_1_1access.html#ade7472cc9b6db9b3cd47fb9f3bc8c450aecae13117d6f0584c25a9da6c8f8415e">access::mode::read</a>, <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/common_8h.html#a01c96dfd06d3493f3cec972d38f45156">COMPUTECPP_ACCESS_TARGET_DEVICE</a>, isPlaceholder &gt; &amp;<a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#aacaa7a26269cdb5e27ea8f221462580e">acc</a>, size_t stride)</td></tr>
<tr class="memdesc:a75f75115658c50f5a5398225241c1c76"><td class="mdescLeft"> </td><td class="mdescRight">Registers a constant memory accessor for DMA transfer.  <a href="#a75f75115658c50f5a5398225241c1c76">More...</a><br></td></tr>
<tr class="separator:a75f75115658c50f5a5398225241c1c76"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7b2ccc6478ac01ce1b9a4f44da52ef12"><td class="memTemplParams" colspan="2">template&lt;typename elemT , int kDims, access::mode kMode, access::target kTarget&gt; </td></tr>
<tr class="memitem:a7b2ccc6478ac01ce1b9a4f44da52ef12"><td class="memTemplItemLeft"> </td><td class="memTemplItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#a7b2ccc6478ac01ce1b9a4f44da52ef12">COMPUTECPP_DEPRECATED_API</a> ("Deprecated Codeplay extension function: " "Bind the null <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1accessor.html">accessor</a> first, then call <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#a953fb3a325258dc660a0c4f9bcce1a9f">require</a>()") void <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#a953fb3a325258dc660a0c4f9bcce1a9f">require</a>(<a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1buffer.html">buffer</a>&lt; elemT</td></tr>
<tr class="memdesc:a7b2ccc6478ac01ce1b9a4f44da52ef12"><td class="mdescLeft"> </td><td class="mdescRight">Function that registers a placeholder accessor with the handler and the associated storage.  <a href="#a7b2ccc6478ac01ce1b9a4f44da52ef12">More...</a><br></td></tr>
<tr class="separator:a7b2ccc6478ac01ce1b9a4f44da52ef12"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aabced7254343b7da6d249db0e31f8954"><td class="memItemLeft">void </td><td class="memItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#aabced7254343b7da6d249db0e31f8954">experimental_depends_on</a> (<a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1event.html">cl::sycl::event</a> e)</td></tr>
<tr class="memdesc:aabced7254343b7da6d249db0e31f8954"><td class="mdescLeft"> </td><td class="mdescRight">Register a single event that this handler should wait for before running.  <a href="#aabced7254343b7da6d249db0e31f8954">More...</a><br></td></tr>
<tr class="separator:aabced7254343b7da6d249db0e31f8954"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a614cb2116ec4e92ca77d9b69b7a2f8ef"><td class="memItemLeft">void </td><td class="memItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#a614cb2116ec4e92ca77d9b69b7a2f8ef">experimental_depends_on</a> (const std::vector&lt; <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1event.html">cl::sycl::event</a> &gt; &amp;v)</td></tr>
<tr class="memdesc:a614cb2116ec4e92ca77d9b69b7a2f8ef"><td class="mdescLeft"> </td><td class="mdescRight">Register a set of events that this handler should wait for before running.  <a href="#a614cb2116ec4e92ca77d9b69b7a2f8ef">More...</a><br></td></tr>
<tr class="separator:a614cb2116ec4e92ca77d9b69b7a2f8ef"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6174a643a561ee432d5d41c691c8a716"><td class="memItemLeft">void </td><td class="memItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#a6174a643a561ee432d5d41c691c8a716">depends_on</a> (<a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1event.html">cl::sycl::event</a> e)</td></tr>
<tr class="memdesc:a6174a643a561ee432d5d41c691c8a716"><td class="mdescLeft"> </td><td class="mdescRight">Register a single event that this handler should wait for before running.  <a href="#a6174a643a561ee432d5d41c691c8a716">More...</a><br></td></tr>
<tr class="separator:a6174a643a561ee432d5d41c691c8a716"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a10c99bd3bc5b5e9764979695bb45c967"><td class="memItemLeft">void </td><td class="memItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#a10c99bd3bc5b5e9764979695bb45c967">depends_on</a> (const std::vector&lt; <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1event.html">cl::sycl::event</a> &gt; &amp;v)</td></tr>
<tr class="memdesc:a10c99bd3bc5b5e9764979695bb45c967"><td class="mdescLeft"> </td><td class="mdescRight">Register a set of events that this handler should wait for before running.  <a href="#a10c99bd3bc5b5e9764979695bb45c967">More...</a><br></td></tr>
<tr class="separator:a10c99bd3bc5b5e9764979695bb45c967"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a8f6357dc65b57f9b2909dd119b245477"><td class="memTemplParams" colspan="2">template&lt;typename TAcc , typename THostPtr , int dims, cl::sycl::access::mode accessMode, cl::sycl::access::target accessTarget, access::placeholder isPlaceholder, COMPUTECPP_ENABLE_IF( TAcc,(detail::can_copy_types&lt; TAcc, THostPtr &gt;::value &amp;&amp; detail::is_read_mode&lt; accessMode &gt;::value)) &gt; </td></tr>
<tr class="memitem:a8f6357dc65b57f9b2909dd119b245477"><td class="memTemplItemLeft">void </td><td class="memTemplItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#a8f6357dc65b57f9b2909dd119b245477">copy</a> (<a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; TAcc, dims, accessMode, accessTarget, isPlaceholder &gt; <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#aacaa7a26269cdb5e27ea8f221462580e">acc</a>, <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl.html#a145741acbe1817e4b03338ffcfd21012">shared_ptr_class</a>&lt; THostPtr &gt; hostPtr)</td></tr>
<tr class="memdesc:a8f6357dc65b57f9b2909dd119b245477"><td class="mdescLeft"> </td><td class="mdescRight">Copies the data from the device accessor to the host pointer.  <a href="#a8f6357dc65b57f9b2909dd119b245477">More...</a><br></td></tr>
<tr class="separator:a8f6357dc65b57f9b2909dd119b245477"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:afe461fb62b7d40ca1aa56c72eecb7746"><td class="memTemplParams" colspan="2">template&lt;typename TAcc , typename THostPtr , int dims, cl::sycl::access::mode accessMode, cl::sycl::access::target accessTarget, access::placeholder isPlaceholder, COMPUTECPP_ENABLE_IF( TAcc,(detail::can_copy_types&lt; THostPtr, TAcc &gt;::value &amp;&amp; detail::is_write_mode&lt; accessMode &gt;::value)) &gt; </td></tr>
<tr class="memitem:afe461fb62b7d40ca1aa56c72eecb7746"><td class="memTemplItemLeft">void </td><td class="memTemplItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#afe461fb62b7d40ca1aa56c72eecb7746">copy</a> (<a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl.html#a145741acbe1817e4b03338ffcfd21012">shared_ptr_class</a>&lt; THostPtr &gt; hostPtr, <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; TAcc, dims, accessMode, accessTarget, isPlaceholder &gt; <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#aacaa7a26269cdb5e27ea8f221462580e">acc</a>)</td></tr>
<tr class="memdesc:afe461fb62b7d40ca1aa56c72eecb7746"><td class="mdescLeft"> </td><td class="mdescRight">Copies the data from the host pointer to the device accessor.  <a href="#afe461fb62b7d40ca1aa56c72eecb7746">More...</a><br></td></tr>
<tr class="separator:afe461fb62b7d40ca1aa56c72eecb7746"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac7f2fcef342337b5d5c84ae903cf062f"><td class="memTemplParams" colspan="2">template&lt;typename TAcc , typename THostPtr , int dims, cl::sycl::access::mode accessMode, cl::sycl::access::target accessTarget, access::placeholder isPlaceholder, COMPUTECPP_ENABLE_IF( TAcc,(detail::can_copy_types&lt; TAcc, THostPtr &gt;::value &amp;&amp; detail::is_read_mode&lt; accessMode &gt;::value)) &gt; </td></tr>
<tr class="memitem:ac7f2fcef342337b5d5c84ae903cf062f"><td class="memTemplItemLeft">void </td><td class="memTemplItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#ac7f2fcef342337b5d5c84ae903cf062f">copy</a> (<a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; TAcc, dims, accessMode, accessTarget, isPlaceholder &gt; <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#aacaa7a26269cdb5e27ea8f221462580e">acc</a>, THostPtr *hostPtr)</td></tr>
<tr class="memdesc:ac7f2fcef342337b5d5c84ae903cf062f"><td class="mdescLeft"> </td><td class="mdescRight">Copies the data from the device accessor to the host pointer.  <a href="#ac7f2fcef342337b5d5c84ae903cf062f">More...</a><br></td></tr>
<tr class="separator:ac7f2fcef342337b5d5c84ae903cf062f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a0ec69c38f3c4cd77095c62adff0dc4b7"><td class="memTemplParams" colspan="2">template&lt;typename TAcc , typename THostPtr , int dims, cl::sycl::access::mode accessMode, cl::sycl::access::target accessTarget, access::placeholder isPlaceholder, COMPUTECPP_ENABLE_IF( TAcc,(detail::can_copy_types&lt; THostPtr, TAcc &gt;::value &amp;&amp; detail::is_write_mode&lt; accessMode &gt;::value)) &gt; </td></tr>
<tr class="memitem:a0ec69c38f3c4cd77095c62adff0dc4b7"><td class="memTemplItemLeft">void </td><td class="memTemplItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#a0ec69c38f3c4cd77095c62adff0dc4b7">copy</a> (const THostPtr *hostPtr, <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; TAcc, dims, accessMode, accessTarget, isPlaceholder &gt; <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#aacaa7a26269cdb5e27ea8f221462580e">acc</a>)</td></tr>
<tr class="memdesc:a0ec69c38f3c4cd77095c62adff0dc4b7"><td class="mdescLeft"> </td><td class="mdescRight">Copies the data from the host pointer to the device accessor.  <a href="#a0ec69c38f3c4cd77095c62adff0dc4b7">More...</a><br></td></tr>
<tr class="separator:a0ec69c38f3c4cd77095c62adff0dc4b7"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a50777df7564aa98bc62b1432416b4c3f"><td class="memTemplParams" colspan="2">template&lt;typename T , typename U , int dimsOrig, int dimsDest, access::mode accModeOrig, access::mode accModeDest, access::target accTargetOrig, access::target accTargetDest, access::placeholder isPlaceholderOrig, access::placeholder isPlaceholderDest, COMPUTECPP_ENABLE_IF(T,((detail::can_copy_types&lt; T, U &gt;::value) &amp;&amp;(detail::is_read_mode&lt; accModeOrig &gt;::value) &amp;&amp;(detail::is_write_mode&lt; accModeDest &gt;::value))) &gt; </td></tr>
<tr class="memitem:a50777df7564aa98bc62b1432416b4c3f"><td class="memTemplItemLeft">void </td><td class="memTemplItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#a50777df7564aa98bc62b1432416b4c3f">copy</a> (<a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; T, dimsOrig, accModeOrig, accTargetOrig, isPlaceholderOrig &gt; originAcc, <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; U, dimsDest, accModeDest, accTargetDest, isPlaceholderDest &gt; destinationAcc)</td></tr>
<tr class="memdesc:a50777df7564aa98bc62b1432416b4c3f"><td class="mdescLeft"> </td><td class="mdescRight">Copies data associated with the origin accessor to the data associated with the destination accessor.  <a href="#a50777df7564aa98bc62b1432416b4c3f">More...</a><br></td></tr>
<tr class="separator:a50777df7564aa98bc62b1432416b4c3f"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad360f52d93770802e350f10754f7ed6d"><td class="memTemplParams" colspan="2">template&lt;typename TAcc , typename T , int dims, cl::sycl::access::mode accessMode, cl::sycl::access::target accessTarget, access::placeholder isPlaceholder, COMPUTECPP_ENABLE_IF(TAcc,(detail::can_copy_types&lt; T, TAcc &gt;::value &amp;&amp; detail::is_write_mode&lt; accessMode &gt;::value)) &gt; </td></tr>
<tr class="memitem:ad360f52d93770802e350f10754f7ed6d"><td class="memTemplItemLeft">void </td><td class="memTemplItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#ad360f52d93770802e350f10754f7ed6d">fill</a> (<a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; TAcc, dims, accessMode, accessTarget, isPlaceholder &gt; <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#aacaa7a26269cdb5e27ea8f221462580e">acc</a>, T val)</td></tr>
<tr class="memdesc:ad360f52d93770802e350f10754f7ed6d"><td class="mdescLeft"> </td><td class="mdescRight">Fills the data associated with the accessor using the scalar value.  <a href="#ad360f52d93770802e350f10754f7ed6d">More...</a><br></td></tr>
<tr class="separator:ad360f52d93770802e350f10754f7ed6d"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a7095e10bde4deca0f823ce471b734c42"><td class="memTemplParams" colspan="2">template&lt;typename T , int dims, access::mode accessMode, access::target accessTarget, access::placeholder isPlaceholder&gt; </td></tr>
<tr class="memitem:a7095e10bde4deca0f823ce471b734c42"><td class="memTemplItemLeft">void </td><td class="memTemplItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#a7095e10bde4deca0f823ce471b734c42">update_host</a> (<a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; T, dims, accessMode, accessTarget, isPlaceholder &gt; <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#aacaa7a26269cdb5e27ea8f221462580e">acc</a>)</td></tr>
<tr class="memdesc:a7095e10bde4deca0f823ce471b734c42"><td class="mdescLeft"> </td><td class="mdescRight">Update the memory object accessed by a given accessor on the host.  <a href="#a7095e10bde4deca0f823ce471b734c42">More...</a><br></td></tr>
<tr class="separator:a7095e10bde4deca0f823ce471b734c42"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a96f34754b90172152e6e68a8b76c0446"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a96f34754b90172152e6e68a8b76c0446"><td class="memTemplItemLeft">void </td><td class="memTemplItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#a96f34754b90172152e6e68a8b76c0446">fill</a> (void *ptr, const T &amp;pattern, size_t count)</td></tr>
<tr class="memdesc:a96f34754b90172152e6e68a8b76c0446"><td class="mdescLeft"> </td><td class="mdescRight">Fills the memory pointed by <code>ptr</code>.  <a href="#a96f34754b90172152e6e68a8b76c0446">More...</a><br></td></tr>
<tr class="separator:a96f34754b90172152e6e68a8b76c0446"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:adc2bc1950d746b68e457cc63c2998055"><td class="memItemLeft">void </td><td class="memItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#adc2bc1950d746b68e457cc63c2998055">memcpy</a> (void *dest, const void *src, size_t size)</td></tr>
<tr class="memdesc:adc2bc1950d746b68e457cc63c2998055"><td class="mdescLeft"> </td><td class="mdescRight">Copies <code>count</code> bytes from <code>src</code> to .  <a href="#adc2bc1950d746b68e457cc63c2998055">More...</a><br></td></tr>
<tr class="separator:adc2bc1950d746b68e457cc63c2998055"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af61a453802ed627abe983fcd7b9024fd"><td class="memItemLeft">void </td><td class="memItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#af61a453802ed627abe983fcd7b9024fd">experimental_prefetch</a> (const void *ptr, size_t size)</td></tr>
<tr class="memdesc:af61a453802ed627abe983fcd7b9024fd"><td class="mdescLeft"> </td><td class="mdescRight">Hints to the SYCL runtime that the data is available earlier than when the USM model would require it.  <a href="#af61a453802ed627abe983fcd7b9024fd">More...</a><br></td></tr>
<tr class="separator:af61a453802ed627abe983fcd7b9024fd"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad67a4a6023c01cb90f7f1357c8b66000"><td class="memItemLeft">void </td><td class="memItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#ad67a4a6023c01cb90f7f1357c8b66000">prefetch</a> (const void *ptr, size_t size)</td></tr>
<tr class="memdesc:ad67a4a6023c01cb90f7f1357c8b66000"><td class="mdescLeft"> </td><td class="mdescRight">Hints to the SYCL runtime that the data is available earlier than when the USM model would require it.  <a href="#ad67a4a6023c01cb90f7f1357c8b66000">More...</a><br></td></tr>
<tr class="separator:ad67a4a6023c01cb90f7f1357c8b66000"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ab4bdf5d8c1017daf847d2113c11242f3"><td class="memItemLeft"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl.html#adee2e3bdfed43ffe0b7ef0ea737c5a4c">kDims</a> &amp; </td><td class="memItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#ab4bdf5d8c1017daf847d2113c11242f3">bufObj</a></td></tr>
<tr class="separator:ab4bdf5d8c1017daf847d2113c11242f3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aacaa7a26269cdb5e27ea8f221462580e"><td class="memItemLeft"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl.html#adee2e3bdfed43ffe0b7ef0ea737c5a4c">kDims</a> const <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; elemT, <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl.html#adee2e3bdfed43ffe0b7ef0ea737c5a4c">kDims</a>, <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl.html#af827bc05849ee05ae978679bca689c43">kMode</a>, <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl.html#af98dc56956ad4fc67c4c52fdfa32f860">kTarget</a>, <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl_1_1access.html#af1c616691dbceeaca9cdd537a8ab0af9a1b756892a15e10bdbdfe033bf55e8d03">access::placeholder::true_t</a> &gt; &amp; </td><td class="memItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#aacaa7a26269cdb5e27ea8f221462580e">acc</a></td></tr>
<tr class="separator:aacaa7a26269cdb5e27ea8f221462580e"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a4768d2e35307c5481d84c015b6f974e2"><td class="memItemLeft">void </td><td class="memItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#a4768d2e35307c5481d84c015b6f974e2">use_kernel_bundle_impl</a> (const dkernelbundle_shptr execBundle)</td></tr>
<tr class="memdesc:a4768d2e35307c5481d84c015b6f974e2"><td class="mdescLeft"> </td><td class="mdescRight">This command group will use device images from the given kernel bundle when invoking kernels.  <a href="#a4768d2e35307c5481d84c015b6f974e2">More...</a><br></td></tr>
<tr class="separator:a4768d2e35307c5481d84c015b6f974e2"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af5e3ae7393de2d7c830d48170ee0c989"><td class="memItemLeft">void </td><td class="memItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#af5e3ae7393de2d7c830d48170ee0c989">update_device_data</a> (const accessor_base &amp;<a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#aacaa7a26269cdb5e27ea8f221462580e">acc</a>, <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl.html#a145741acbe1817e4b03338ffcfd21012">shared_ptr_class</a>&lt; void &gt; hostPtr, <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl_1_1access.html#ade7472cc9b6db9b3cd47fb9f3bc8c450">cl::sycl::access::mode</a> accessMode, bool userProvidedPtr)</td></tr>
<tr class="memdesc:af5e3ae7393de2d7c830d48170ee0c989"><td class="mdescLeft"> </td><td class="mdescRight">Updates device data by copying to/from the device.  <a href="#af5e3ae7393de2d7c830d48170ee0c989">More...</a><br></td></tr>
<tr class="separator:af5e3ae7393de2d7c830d48170ee0c989"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2431290ca2ef1df8cff33d8110a6f297"><td class="memItemLeft">void </td><td class="memItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#a2431290ca2ef1df8cff33d8110a6f297">update_host_impl</a> (const accessor_base &amp;<a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#aacaa7a26269cdb5e27ea8f221462580e">acc</a>)</td></tr>
<tr class="memdesc:a2431290ca2ef1df8cff33d8110a6f297"><td class="mdescLeft"> </td><td class="mdescRight">Implementation for update_host.  <a href="#a2431290ca2ef1df8cff33d8110a6f297">More...</a><br></td></tr>
<tr class="separator:a2431290ca2ef1df8cff33d8110a6f297"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6aa01f0e8ea455cbaa5517dd1e9a33b8"><td class="memItemLeft">void </td><td class="memItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#a6aa01f0e8ea455cbaa5517dd1e9a33b8">copy_in_device</a> (const accessor_base &amp;originAcc, const accessor_base &amp;destinationAcc)</td></tr>
<tr class="memdesc:a6aa01f0e8ea455cbaa5517dd1e9a33b8"><td class="mdescLeft"> </td><td class="mdescRight">Copies data associated with the origin accessor to the data associated with the destination accessor.  <a href="#a6aa01f0e8ea455cbaa5517dd1e9a33b8">More...</a><br></td></tr>
<tr class="separator:a6aa01f0e8ea455cbaa5517dd1e9a33b8"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ae6d7565b85886156bf0a9e2b775472fb"><td class="memItemLeft">void </td><td class="memItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#ae6d7565b85886156bf0a9e2b775472fb">fill</a> (const accessor_base &amp;<a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#aacaa7a26269cdb5e27ea8f221462580e">acc</a>, const void *patternData, const size_t patternSize)</td></tr>
<tr class="memdesc:ae6d7565b85886156bf0a9e2b775472fb"><td class="mdescLeft"> </td><td class="mdescRight">Fills the range of the accessor with value of hostScalarPtr[0]}.  <a href="#ae6d7565b85886156bf0a9e2b775472fb">More...</a><br></td></tr>
<tr class="separator:ae6d7565b85886156bf0a9e2b775472fb"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af3387bd5b8faaba3ed169d9fb45b8952"><td class="memItemLeft">void </td><td class="memItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#af3387bd5b8faaba3ed169d9fb45b8952">fill</a> (void *ptr, const void *patternData, size_t patternSize, size_t size)</td></tr>
<tr class="memdesc:af3387bd5b8faaba3ed169d9fb45b8952"><td class="mdescLeft"> </td><td class="mdescRight">Fills the memory pointed by <code>ptr</code>.  <a href="#af3387bd5b8faaba3ed169d9fb45b8952">More...</a><br></td></tr>
<tr class="separator:af3387bd5b8faaba3ed169d9fb45b8952"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a2d31acb51ab89306691a73d9c188b21c"><td class="memItemLeft">void </td><td class="memItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#a2d31acb51ab89306691a73d9c188b21c">interop_task_impl</a> (const detail::interop_task_ptr &amp;hostTaskCallable)</td></tr>
<tr class="memdesc:a2d31acb51ab89306691a73d9c188b21c"><td class="mdescLeft"> </td><td class="mdescRight">Schedules a host task with an interop_handle object.  <a href="#a2d31acb51ab89306691a73d9c188b21c">More...</a><br></td></tr>
<tr class="separator:a2d31acb51ab89306691a73d9c188b21c"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af6f11cc2e4d07fdcd46f39263c86dc3a"><td class="memItemLeft"> </td><td class="memItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#af6f11cc2e4d07fdcd46f39263c86dc3a">handler</a> (const dqueue_shptr &amp;q, const dqueue_shptr &amp;fallbackQueue=nullptr)</td></tr>
<tr class="memdesc:af6f11cc2e4d07fdcd46f39263c86dc3a"><td class="mdescLeft"> </td><td class="mdescRight">Creates a handler for an specific queue.  <a href="#af6f11cc2e4d07fdcd46f39263c86dc3a">More...</a><br></td></tr>
<tr class="separator:af6f11cc2e4d07fdcd46f39263c86dc3a"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:adaa9e1b9c31397bbfcb94a4161026326"><td class="memItemLeft"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1context.html">context</a> </td><td class="memItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#adaa9e1b9c31397bbfcb94a4161026326">get_context</a> () const</td></tr>
<tr class="memdesc:adaa9e1b9c31397bbfcb94a4161026326"><td class="mdescLeft"> </td><td class="mdescRight">Returns the current context for the command group.  <a href="#adaa9e1b9c31397bbfcb94a4161026326">More...</a><br></td></tr>
<tr class="separator:adaa9e1b9c31397bbfcb94a4161026326"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aaaff06d227e31e7f29d1968a52320321"><td class="memItemLeft">ddevice_wkptr </td><td class="memItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#aaaff06d227e31e7f29d1968a52320321">get_device_weak</a> () const</td></tr>
<tr class="memdesc:aaaff06d227e31e7f29d1968a52320321"><td class="mdescLeft"> </td><td class="mdescRight">Returns the current device for the command group.  <a href="#aaaff06d227e31e7f29d1968a52320321">More...</a><br></td></tr>
<tr class="separator:aaaff06d227e31e7f29d1968a52320321"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a37bf60ec03546b51fe5e7c7dc60c57ab"><td class="memItemLeft">void </td><td class="memItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#a37bf60ec03546b51fe5e7c7dc60c57ab">execute_kernel_single_task_ptr</a> (const detail::nd_range_base &amp;ndRange, const <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1kernel.html">kernel</a> &amp;syclKernel, const detail::single_task_ptr &amp;funcPtr, detail::enqueue_device_kernel_command *currentCommand)</td></tr>
<tr class="memdesc:a37bf60ec03546b51fe5e7c7dc60c57ab"><td class="mdescLeft"> </td><td class="mdescRight">Creates the internal structures to execute the kernel.  <a href="#a37bf60ec03546b51fe5e7c7dc60c57ab">More...</a><br></td></tr>
<tr class="separator:a37bf60ec03546b51fe5e7c7dc60c57ab"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ad4624999c921f57cde7c599752cddc69"><td class="memItemLeft">void </td><td class="memItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#ad4624999c921f57cde7c599752cddc69">execute_kernel_parallel_for_ptr</a> (const detail::nd_range_base &amp;ndRange, const <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1kernel.html">kernel</a> &amp;syclKernel, const detail::parallel_for_ptr &amp;funcPtr, detail::enqueue_device_kernel_command *currentCommand, int dimensions)</td></tr>
<tr class="separator:ad4624999c921f57cde7c599752cddc69"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af0a007e26d5c1b02d185e98e8df8b205"><td class="memItemLeft">void </td><td class="memItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#af0a007e26d5c1b02d185e98e8df8b205">execute_kernel_parallel_for_id_ptr</a> (const detail::nd_range_base &amp;ndRange, const <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1kernel.html">kernel</a> &amp;syclKernel, const detail::parallel_for_id_ptr &amp;funcPtr, detail::enqueue_device_kernel_command *currentCommand, int dimensions)</td></tr>
<tr class="separator:af0a007e26d5c1b02d185e98e8df8b205"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:af6603f931613f0d1f07bce1e11082786"><td class="memItemLeft">void </td><td class="memItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#af6603f931613f0d1f07bce1e11082786">execute_kernel_parallel_for_work_group_ptr</a> (const detail::nd_range_base &amp;ndRange, const <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1kernel.html">kernel</a> &amp;syclKernel, const detail::parallel_for_work_group_ptr &amp;funcPtr, detail::enqueue_device_kernel_command *currentCommand, int dimensions)</td></tr>
<tr class="separator:af6603f931613f0d1f07bce1e11082786"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a6b1595e93690c230e23da413f3d999ba"><td class="memItemLeft">void </td><td class="memItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#a6b1595e93690c230e23da413f3d999ba">process_functor_arguments_impl</a> (<a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1kernel.html">kernel</a> syclKernel, detail::binary_address functorBuffer, const detail::functor_arg_descriptor &amp;argDesc, detail::enqueue_device_kernel_command *currentCommand)</td></tr>
<tr class="memdesc:a6b1595e93690c230e23da413f3d999ba"><td class="mdescLeft"> </td><td class="mdescRight">Gets the parameters from a functor and sets them as OpenCL arguments.  <a href="#a6b1595e93690c230e23da413f3d999ba">More...</a><br></td></tr>
<tr class="separator:a6b1595e93690c230e23da413f3d999ba"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a79909103961de6237c32643e43f57d13"><td class="memItemLeft">void </td><td class="memItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#a79909103961de6237c32643e43f57d13">require</a> (const accessor_base &amp;<a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#aacaa7a26269cdb5e27ea8f221462580e">acc</a>)</td></tr>
<tr class="memdesc:a79909103961de6237c32643e43f57d13"><td class="mdescLeft"> </td><td class="mdescRight">Internal function that registers a placeholder accessor with the handler.  <a href="#a79909103961de6237c32643e43f57d13">More...</a><br></td></tr>
<tr class="separator:a79909103961de6237c32643e43f57d13"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a481be0c41842998c3593da40ef349df3"><td class="memItemLeft">void </td><td class="memItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#a481be0c41842998c3593da40ef349df3">require</a> (const accessor_base &amp;<a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#aacaa7a26269cdb5e27ea8f221462580e">acc</a>, dmem_shptr memObj, <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl_1_1access.html#ade7472cc9b6db9b3cd47fb9f3bc8c450">access::mode</a> mode, <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl_1_1access.html#a6874ae9aff44c453a412c2adefb1b9f7">access::target</a> target)</td></tr>
<tr class="memdesc:a481be0c41842998c3593da40ef349df3"><td class="mdescLeft"> </td><td class="mdescRight">Internal function that registers a placeholder accessor with the handler.  <a href="#a481be0c41842998c3593da40ef349df3">More...</a><br></td></tr>
<tr class="separator:a481be0c41842998c3593da40ef349df3"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac3358a20e49c3510e7ec3b4e8728f483"><td class="memItemLeft">void </td><td class="memItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#ac3358a20e49c3510e7ec3b4e8728f483">register_for_dma</a> (accessor_base &amp;<a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#aacaa7a26269cdb5e27ea8f221462580e">acc</a>, size_t strideBytes)</td></tr>
<tr class="memdesc:ac3358a20e49c3510e7ec3b4e8728f483"><td class="mdescLeft"> </td><td class="mdescRight">Registers an accessor for DMA transfer.  <a href="#ac3358a20e49c3510e7ec3b4e8728f483">More...</a><br></td></tr>
<tr class="separator:ac3358a20e49c3510e7ec3b4e8728f483"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a352d6db9cc631ff57564bc590a817804"><td class="memItemLeft">detail::enqueue_device_kernel_command * </td><td class="memItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#a352d6db9cc631ff57564bc590a817804">create_kernel_command_group</a> (<a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1kernel.html">kernel</a> &amp;syclKernel)</td></tr>
<tr class="memdesc:a352d6db9cc631ff57564bc590a817804"><td class="mdescLeft"> </td><td class="mdescRight">Creates a kernel command group Internal implementation.  <a href="#a352d6db9cc631ff57564bc590a817804">More...</a><br></td></tr>
<tr class="separator:a352d6db9cc631ff57564bc590a817804"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a51fc701fbd276e05ed83e48883542119"><td class="memItemLeft">detail::index_array </td><td class="memItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#a51fc701fbd276e05ed83e48883542119">get_optimal_workgroup_size</a> (const <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1kernel.html">kernel</a> &amp;syclKernel)</td></tr>
<tr class="memdesc:a51fc701fbd276e05ed83e48883542119"><td class="mdescLeft"> </td><td class="mdescRight">Gets the optimal workgroup size for the current device and the given kernel.  <a href="#a51fc701fbd276e05ed83e48883542119">More...</a><br></td></tr>
<tr class="separator:a51fc701fbd276e05ed83e48883542119"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a66840e5d814dd97aa63121f3ce7012b1"><td class="memItemLeft">bool </td><td class="memItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#a66840e5d814dd97aa63121f3ce7012b1">has_kernel_bundle</a> () const</td></tr>
<tr class="memdesc:a66840e5d814dd97aa63121f3ce7012b1"><td class="mdescLeft"> </td><td class="mdescRight">Returns true if use_kernel_bundle(bundle) has been called with the handler.  <a href="#a66840e5d814dd97aa63121f3ce7012b1">More...</a><br></td></tr>
<tr class="separator:a66840e5d814dd97aa63121f3ce7012b1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a783b418efd3c305647846dd1724c18ea"><td class="memItemLeft"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1program.html">program</a> </td><td class="memItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#a783b418efd3c305647846dd1724c18ea">get_kernel_bundle_program</a> () const</td></tr>
<tr class="memdesc:a783b418efd3c305647846dd1724c18ea"><td class="mdescLeft"> </td><td class="mdescRight">Get the program to use from a kernel bundle.  <a href="#a783b418efd3c305647846dd1724c18ea">More...</a><br></td></tr>
<tr class="separator:a783b418efd3c305647846dd1724c18ea"><td class="memSeparator" colspan="2"> </td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a65cd7a5b02ea526bb946eff87188afa1"><td class="memItemLeft">dtrans_uptr </td><td class="memItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#a65cd7a5b02ea526bb946eff87188afa1">m_trans</a></td></tr>
<tr class="memdesc:a65cd7a5b02ea526bb946eff87188afa1"><td class="mdescLeft"> </td><td class="mdescRight">Internal transaction associated with the handler.  <a href="#a65cd7a5b02ea526bb946eff87188afa1">More...</a><br></td></tr>
<tr class="separator:a65cd7a5b02ea526bb946eff87188afa1"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a53746faca0e6189185ff0218bbda5f22"><td class="memItemLeft">dqueue_shptr </td><td class="memItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#a53746faca0e6189185ff0218bbda5f22">m_queue</a></td></tr>
<tr class="memdesc:a53746faca0e6189185ff0218bbda5f22"><td class="mdescLeft"> </td><td class="mdescRight">Queue to which this handler was submitted to.  <a href="#a53746faca0e6189185ff0218bbda5f22">More...</a><br></td></tr>
<tr class="separator:a53746faca0e6189185ff0218bbda5f22"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:aca8ae9b682242271c828237b136d2646"><td class="memItemLeft">dqueue_shptr </td><td class="memItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#aca8ae9b682242271c828237b136d2646">m_fallbackQueue</a></td></tr>
<tr class="memdesc:aca8ae9b682242271c828237b136d2646"><td class="mdescLeft"> </td><td class="mdescRight">Pointer to the fallback queue (if any)  <a href="#aca8ae9b682242271c828237b136d2646">More...</a><br></td></tr>
<tr class="separator:aca8ae9b682242271c828237b136d2646"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:a3d6d146a3f005c5a27e653a5dab16550"><td class="memItemLeft"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl.html#a0a3b58674c77d248758b6bee05800ac5">vector_class</a>&lt; add_param_func_t &gt; </td><td class="memItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#a3d6d146a3f005c5a27e653a5dab16550">m_paramVec</a></td></tr>
<tr class="separator:a3d6d146a3f005c5a27e653a5dab16550"><td class="memSeparator" colspan="2"> </td></tr>
<tr class="memitem:ac7bffc7ce382906014d6cfaafb7c75e9"><td class="memItemLeft">unsigned </td><td class="memItemRight"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#ac7bffc7ce382906014d6cfaafb7c75e9">m_numKernels</a></td></tr>
<tr class="memdesc:ac7bffc7ce382906014d6cfaafb7c75e9"><td class="mdescLeft"> </td><td class="mdescRight">Number of kernels in the command group.  <a href="#ac7bffc7ce382906014d6cfaafb7c75e9">More...</a><br></td></tr>
<tr class="separator:ac7bffc7ce382906014d6cfaafb7c75e9"><td class="memSeparator" colspan="2"> </td></tr>
</table>
<a id="details" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A handler gives user access to command group scope functionality, such as API calls. </p>
<p>This simplifies the interface, as the command group class is not required anymore and the scope is explicit for accessors and API entries.</p>
<p>It is also used by accessors to get the current command group scope. Handlers can only be constructed from within queues. For the time being, the deprecated command group function also can create handlers.</p>
<p>The templated-side of the API entries is defined here. Some API entries are explicitly deleted to shield users from weird template errors caused by enable_if macros. In particular, if there is a pointer to a kernel instead of a kernel, the template deduction fails and causes a massive template error. However, using the deleted API entry the user sees an explicit error because they are using a non-valid interface. </p>
<p class="definition">Definition at line <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html#l00210">210</a> of file <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html">apis.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ad13964683fae164ccba5eff3eccb557d" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad13964683fae164ccba5eff3eccb557d">◆ </a></span>~handler()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">COMPUTECPP_TEST_VIRTUAL cl::sycl::handler::~handler </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Destructor of the handler, implementation on the cpp file so the default_deleter can see the implementation of the internal transaction object. </p>
</div>
</div>
<a id="af6f11cc2e4d07fdcd46f39263c86dc3a" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6f11cc2e4d07fdcd46f39263c86dc3a">◆ </a></span>handler()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">cl::sycl::handler::handler </td>
<td>(</td>
<td class="paramtype">const dqueue_shptr &amp; </td>
<td class="paramname"><em>q</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const dqueue_shptr &amp; </td>
<td class="paramname"><em>fallbackQueue</em> = <code>nullptr</code> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">explicit</span><span class="mlabel">protected</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Creates a handler for an specific queue. </p>
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7b2ccc6478ac01ce1b9a4f44da52ef12" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b2ccc6478ac01ce1b9a4f44da52ef12">◆ </a></span>COMPUTECPP_DEPRECATED_API()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename elemT , int kDims, access::mode kMode, access::target kTarget&gt; </div>
<table class="memname">
<tr>
<td class="memname">cl::sycl::handler::COMPUTECPP_DEPRECATED_API </td>
<td>(</td>
<td class="paramtype">"Deprecated Codeplay extension function: " "Bind the null <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1accessor.html">accessor</a> </td>
<td class="paramname"><em>first</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">then call <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#a953fb3a325258dc660a0c4f9bcce1a9f">require</a>()" </td>
<td class="paramname"> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Function that registers a placeholder accessor with the handler and the associated storage. </p>
<p>Defined in Codeplay Extension CP004. Will fail if accessor already associated with storage. </p><dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">buf</td><td>Buffer object </td></tr>
<tr><td class="paramname">acc</td><td>Placeholder accessor </td></tr>
</table>
</dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/deprecated.html#_deprecated000007">Deprecated:</a></b></dt><dd>Bind the null accessor first, then call <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#a953fb3a325258dc660a0c4f9bcce1a9f">require()</a> </dd></dl>
</div>
</div>
<a id="a8f6357dc65b57f9b2909dd119b245477" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f6357dc65b57f9b2909dd119b245477">◆ </a></span>copy() <span class="overload">[1/5]</span></h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TAcc , typename THostPtr , int dims, cl::sycl::access::mode accessMode, cl::sycl::access::target accessTarget, access::placeholder isPlaceholder, COMPUTECPP_ENABLE_IF( TAcc,(detail::can_copy_types&lt; TAcc, THostPtr &gt;::value &amp;&amp; detail::is_read_mode&lt; accessMode &gt;::value)) &gt; </div>
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void cl::sycl::handler::copy </td>
<td>(</td>
<td class="paramtype"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; TAcc, dims, accessMode, accessTarget, isPlaceholder &gt; </td>
<td class="paramname"><em>acc</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl.html#a145741acbe1817e4b03338ffcfd21012">shared_ptr_class</a>&lt; THostPtr &gt; </td>
<td class="paramname"><em>hostPtr</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Copies the data from the device accessor to the host pointer. </p>
<p>hostPtr must have enough space allocated to match the size of the accessor data.</p>
<p>The underlying type of the accessor and the host pointer must match</p><ul>
<li>Accessor type can be const</li>
<li>At least one type is allowed to be void <dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tr><td class="paramname">TAcc</td><td>Underlying type of the data associated with the accessor </td></tr>
<tr><td class="paramname">THostPtr</td><td>Underlying type of the host pointer data </td></tr>
<tr><td class="paramname">dims</td><td>Number of dimensions of the accessor </td></tr>
<tr><td class="paramname">accessMode</td><td>Access mode of the accessor </td></tr>
<tr><td class="paramname">accessTarget</td><td>Access target of the accessor </td></tr>
<tr><td class="paramname">isPlaceholder</td><td>Whether the accessor is a placeholder </td></tr>
<tr><td class="paramname">COMPUTECPP_ENABLE_IF</td><td>The function is only valid when the access mode includes read access </td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">acc</td><td>Accessor that is used to access the buffer or image </td></tr>
<tr><td class="paramname">hostPtr</td><td>Host pointer that will be updated </td></tr>
</table>
</dd>
</dl>
</li>
</ul>
<p class="definition">Definition at line <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html#l01189">1189</a> of file <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html">apis.h</a>.</p>
</div>
</div>
<a id="afe461fb62b7d40ca1aa56c72eecb7746" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe461fb62b7d40ca1aa56c72eecb7746">◆ </a></span>copy() <span class="overload">[2/5]</span></h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TAcc , typename THostPtr , int dims, cl::sycl::access::mode accessMode, cl::sycl::access::target accessTarget, access::placeholder isPlaceholder, COMPUTECPP_ENABLE_IF( TAcc,(detail::can_copy_types&lt; THostPtr, TAcc &gt;::value &amp;&amp; detail::is_write_mode&lt; accessMode &gt;::value)) &gt; </div>
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void cl::sycl::handler::copy </td>
<td>(</td>
<td class="paramtype"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl.html#a145741acbe1817e4b03338ffcfd21012">shared_ptr_class</a>&lt; THostPtr &gt; </td>
<td class="paramname"><em>hostPtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; TAcc, dims, accessMode, accessTarget, isPlaceholder &gt; </td>
<td class="paramname"><em>acc</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Copies the data from the host pointer to the device accessor. </p>
<p>hostPtr must have enough space allocated to match the size of the accessor data.</p>
<p>The underlying type of the host pointer and the accessor must match</p><ul>
<li>Host pointer type can be const</li>
<li>At least one type is allowed to be void <dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tr><td class="paramname">THostPtr</td><td>Underlying type of the host pointer data </td></tr>
<tr><td class="paramname">TAcc</td><td>Underlying type of the data associated with the accessor </td></tr>
<tr><td class="paramname">dims</td><td>Number of dimensions of the accessor </td></tr>
<tr><td class="paramname">accessMode</td><td>Access mode of the accessor </td></tr>
<tr><td class="paramname">accessTarget</td><td>Access target of the accessor </td></tr>
<tr><td class="paramname">isPlaceholder</td><td>Whether the accessor is a placeholder </td></tr>
<tr><td class="paramname">COMPUTECPP_ENABLE_IF</td><td>The function is only valid when the access mode includes write access </td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">hostPtr</td><td>Host pointer that points to the new data </td></tr>
<tr><td class="paramname">acc</td><td>Accessor that is used to access the buffer or image </td></tr>
</table>
</dd>
</dl>
</li>
</ul>
<p class="definition">Definition at line <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html#l01222">1222</a> of file <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html">apis.h</a>.</p>
</div>
</div>
<a id="ac7f2fcef342337b5d5c84ae903cf062f" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7f2fcef342337b5d5c84ae903cf062f">◆ </a></span>copy() <span class="overload">[3/5]</span></h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TAcc , typename THostPtr , int dims, cl::sycl::access::mode accessMode, cl::sycl::access::target accessTarget, access::placeholder isPlaceholder, COMPUTECPP_ENABLE_IF( TAcc,(detail::can_copy_types&lt; TAcc, THostPtr &gt;::value &amp;&amp; detail::is_read_mode&lt; accessMode &gt;::value)) &gt; </div>
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void cl::sycl::handler::copy </td>
<td>(</td>
<td class="paramtype"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; TAcc, dims, accessMode, accessTarget, isPlaceholder &gt; </td>
<td class="paramname"><em>acc</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">THostPtr * </td>
<td class="paramname"><em>hostPtr</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Copies the data from the device accessor to the host pointer. </p>
<p>hostPtr must have enough space allocated to match the size of the accessor data.</p>
<p>The underlying type of the accessor and the host pointer must match</p><ul>
<li>Accessor type can be const</li>
<li>At least one type is allowed to be void <dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tr><td class="paramname">TAcc</td><td>Underlying type of the data associated with the accessor </td></tr>
<tr><td class="paramname">THostPtr</td><td>Underlying type of the host pointer data </td></tr>
<tr><td class="paramname">dims</td><td>Number of dimensions of the accessor </td></tr>
<tr><td class="paramname">accessMode</td><td>Access mode of the accessor </td></tr>
<tr><td class="paramname">accessTarget</td><td>Access target of the accessor </td></tr>
<tr><td class="paramname">isPlaceholder</td><td>Whether the accessor is a placeholder </td></tr>
<tr><td class="paramname">COMPUTECPP_ENABLE_IF</td><td>The function is only valid when the access mode includes read access </td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">acc</td><td>Accessor that is used to access the buffer or image </td></tr>
<tr><td class="paramname">hostPtr</td><td>Host pointer that will be updated </td></tr>
</table>
</dd>
</dl>
</li>
</ul>
<p class="definition">Definition at line <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html#l01257">1257</a> of file <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html">apis.h</a>.</p>
</div>
</div>
<a id="a0ec69c38f3c4cd77095c62adff0dc4b7" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ec69c38f3c4cd77095c62adff0dc4b7">◆ </a></span>copy() <span class="overload">[4/5]</span></h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TAcc , typename THostPtr , int dims, cl::sycl::access::mode accessMode, cl::sycl::access::target accessTarget, access::placeholder isPlaceholder, COMPUTECPP_ENABLE_IF( TAcc,(detail::can_copy_types&lt; THostPtr, TAcc &gt;::value &amp;&amp; detail::is_write_mode&lt; accessMode &gt;::value)) &gt; </div>
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void cl::sycl::handler::copy </td>
<td>(</td>
<td class="paramtype">const THostPtr * </td>
<td class="paramname"><em>hostPtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; TAcc, dims, accessMode, accessTarget, isPlaceholder &gt; </td>
<td class="paramname"><em>acc</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Copies the data from the host pointer to the device accessor. </p>
<p>hostPtr must have enough space allocated to match the size of the accessor data.</p>
<p>The underlying type of the host pointer and the accessor must match</p><ul>
<li>Host pointer type can be const</li>
<li>At least one type is allowed to be void <dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tr><td class="paramname">THostPtr</td><td>Underlying type of the host pointer data </td></tr>
<tr><td class="paramname">TAcc</td><td>Underlying type of the data associated with the accessor </td></tr>
<tr><td class="paramname">dims</td><td>Number of dimensions of the accessor </td></tr>
<tr><td class="paramname">accessMode</td><td>Access mode of the accessor </td></tr>
<tr><td class="paramname">accessTarget</td><td>Access target of the accessor </td></tr>
<tr><td class="paramname">isPlaceholder</td><td>Whether the accessor is a placeholder </td></tr>
<tr><td class="paramname">COMPUTECPP_ENABLE_IF</td><td>The function is only valid when the access mode includes write access </td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">hostPtr</td><td>Host pointer that points to the new data </td></tr>
<tr><td class="paramname">acc</td><td>Accessor that is used to access the buffer or image </td></tr>
</table>
</dd>
</dl>
</li>
</ul>
<p class="definition">Definition at line <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html#l01291">1291</a> of file <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html">apis.h</a>.</p>
</div>
</div>
<a id="a50777df7564aa98bc62b1432416b4c3f" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50777df7564aa98bc62b1432416b4c3f">◆ </a></span>copy() <span class="overload">[5/5]</span></h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename U , int dimsOrig, int dimsDest, access::mode accModeOrig, access::mode accModeDest, access::target accTargetOrig, access::target accTargetDest, access::placeholder isPlaceholderOrig, access::placeholder isPlaceholderDest, COMPUTECPP_ENABLE_IF(T,((detail::can_copy_types&lt; T, U &gt;::value) &amp;&amp;(detail::is_read_mode&lt; accModeOrig &gt;::value) &amp;&amp;(detail::is_write_mode&lt; accModeDest &gt;::value))) &gt; </div>
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void cl::sycl::handler::copy </td>
<td>(</td>
<td class="paramtype"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; T, dimsOrig, accModeOrig, accTargetOrig, isPlaceholderOrig &gt; </td>
<td class="paramname"><em>originAcc</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; U, dimsDest, accModeDest, accTargetDest, isPlaceholderDest &gt; </td>
<td class="paramname"><em>destinationAcc</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Copies data associated with the origin accessor to the data associated with the destination accessor. </p>
<p>There are a few restrictions on the accessors:</p><ul>
<li>The underlying type and number of dimensions must match<ul>
<li>Origin type can be const</li>
</ul>
</li>
<li>The origin accessor access mode must include read access</li>
<li>The destination accessor access mode must include write access</li>
<li>The size of the destination accessor data must be enough to hold the data from the origin accessor <dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tr><td class="paramname">T</td><td>Underlying type of the data associated with the origin accessor </td></tr>
<tr><td class="paramname">U</td><td>Underlying type of the data associated with the destination accessors </td></tr>
<tr><td class="paramname">dimsOrig</td><td>Number of dimensions of the origin accessor </td></tr>
<tr><td class="paramname">dimsDest</td><td>Number of dimensions of the destination accessor </td></tr>
<tr><td class="paramname">accModeOrig</td><td>Access mode of the origin accessor </td></tr>
<tr><td class="paramname">accModeDest</td><td>Access mode of the destination accessor </td></tr>
<tr><td class="paramname">accTargetOrig</td><td>Access target of the origin accessor </td></tr>
<tr><td class="paramname">accTargetDest</td><td>Access target of the destination accessor </td></tr>
<tr><td class="paramname">isPlaceholder</td><td>Whether the origin accessor is a placeholder </td></tr>
<tr><td class="paramname">isPlaceholder</td><td>Whether the destination accessor is a placeholder </td></tr>
<tr><td class="paramname">COMPUTECPP_ENABLE_IF</td><td>Checks that the accessor types conform to the restrictions. </td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">originAcc</td><td>Accessor with the data that will be copied from </td></tr>
<tr><td class="paramname">destinationAcc</td><td>Accessor with the data that will be copied to </td></tr>
</table>
</dd>
</dl>
</li>
</ul>
<p class="definition">Definition at line <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html#l01337">1337</a> of file <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html">apis.h</a>.</p>
</div>
</div>
<a id="a6aa01f0e8ea455cbaa5517dd1e9a33b8" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aa01f0e8ea455cbaa5517dd1e9a33b8">◆ </a></span>copy_in_device()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void cl::sycl::handler::copy_in_device </td>
<td>(</td>
<td class="paramtype">const accessor_base &amp; </td>
<td class="paramname"><em>originAcc</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const accessor_base &amp; </td>
<td class="paramname"><em>destinationAcc</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Copies data associated with the origin accessor to the data associated with the destination accessor. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">originAcc</td><td>Accessor with the data that will be copied from </td></tr>
<tr><td class="paramname">destinationAcc</td><td>Accessor with the data that will be copied to </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a352d6db9cc631ff57564bc590a817804" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a352d6db9cc631ff57564bc590a817804">◆ </a></span>create_kernel_command_group()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">detail::enqueue_device_kernel_command* cl::sycl::handler::create_kernel_command_group </td>
<td>(</td>
<td class="paramtype"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1kernel.html">kernel</a> &amp; </td>
<td class="paramname"><em>syclKernel</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Creates a kernel command group Internal implementation. </p>
<dl><dt>Returns</dt><dd>Pointer to the newly created command </dd></dl>
</div>
</div>
<a id="a6174a643a561ee432d5d41c691c8a716" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6174a643a561ee432d5d41c691c8a716">◆ </a></span>depends_on() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void cl::sycl::handler::depends_on </td>
<td>(</td>
<td class="paramtype"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1event.html">cl::sycl::event</a> </td>
<td class="paramname"><em>e</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Register a single event that this handler should wait for before running. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">e</td><td>The event that the handler should wait for before running. </td></tr>
</table>
</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html#l01133">1133</a> of file <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html">apis.h</a>.</p>
</div>
</div>
<a id="a10c99bd3bc5b5e9764979695bb45c967" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10c99bd3bc5b5e9764979695bb45c967">◆ </a></span>depends_on() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void cl::sycl::handler::depends_on </td>
<td>(</td>
<td class="paramtype">const std::vector&lt; <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1event.html">cl::sycl::event</a> &gt; &amp; </td>
<td class="paramname"><em>v</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Register a set of events that this handler should wait for before running. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">v</td><td>a vector of events. </td></tr>
</table>
</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html#l01138">1138</a> of file <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html">apis.h</a>.</p>
</div>
</div>
<a id="af0a007e26d5c1b02d185e98e8df8b205" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0a007e26d5c1b02d185e98e8df8b205">◆ </a></span>execute_kernel_parallel_for_id_ptr()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void cl::sycl::handler::execute_kernel_parallel_for_id_ptr </td>
<td>(</td>
<td class="paramtype">const detail::nd_range_base &amp; </td>
<td class="paramname"><em>ndRange</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1kernel.html">kernel</a> &amp; </td>
<td class="paramname"><em>syclKernel</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const detail::parallel_for_id_ptr &amp; </td>
<td class="paramname"><em>funcPtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">detail::enqueue_device_kernel_command * </td>
<td class="paramname"><em>currentCommand</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>dimensions</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="ad4624999c921f57cde7c599752cddc69" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4624999c921f57cde7c599752cddc69">◆ </a></span>execute_kernel_parallel_for_ptr()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void cl::sycl::handler::execute_kernel_parallel_for_ptr </td>
<td>(</td>
<td class="paramtype">const detail::nd_range_base &amp; </td>
<td class="paramname"><em>ndRange</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1kernel.html">kernel</a> &amp; </td>
<td class="paramname"><em>syclKernel</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const detail::parallel_for_ptr &amp; </td>
<td class="paramname"><em>funcPtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">detail::enqueue_device_kernel_command * </td>
<td class="paramname"><em>currentCommand</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>dimensions</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="af6603f931613f0d1f07bce1e11082786" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6603f931613f0d1f07bce1e11082786">◆ </a></span>execute_kernel_parallel_for_work_group_ptr()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void cl::sycl::handler::execute_kernel_parallel_for_work_group_ptr </td>
<td>(</td>
<td class="paramtype">const detail::nd_range_base &amp; </td>
<td class="paramname"><em>ndRange</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1kernel.html">kernel</a> &amp; </td>
<td class="paramname"><em>syclKernel</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const detail::parallel_for_work_group_ptr &amp; </td>
<td class="paramname"><em>funcPtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">detail::enqueue_device_kernel_command * </td>
<td class="paramname"><em>currentCommand</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">int </td>
<td class="paramname"><em>dimensions</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
</div>
</div>
<a id="a37bf60ec03546b51fe5e7c7dc60c57ab" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37bf60ec03546b51fe5e7c7dc60c57ab">◆ </a></span>execute_kernel_single_task_ptr()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void cl::sycl::handler::execute_kernel_single_task_ptr </td>
<td>(</td>
<td class="paramtype">const detail::nd_range_base &amp; </td>
<td class="paramname"><em>ndRange</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1kernel.html">kernel</a> &amp; </td>
<td class="paramname"><em>syclKernel</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const detail::single_task_ptr &amp; </td>
<td class="paramname"><em>funcPtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">detail::enqueue_device_kernel_command * </td>
<td class="paramname"><em>currentCommand</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Creates the internal structures to execute the kernel. </p>
<p>This function is explicitly instantiated on the cpp file for those FunctorPtr types supported.</p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">nd_range_base</td><td>The given nd range </td></tr>
<tr><td class="paramname">syclKernel</td><td>The SYCL device kernel </td></tr>
<tr><td class="paramname">FunctorPtr</td><td>The std::function pointer to the user functor </td></tr>
<tr><td class="paramname">currentCommand</td><td>The command currently being executing </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="aabced7254343b7da6d249db0e31f8954" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabced7254343b7da6d249db0e31f8954">◆ </a></span>experimental_depends_on() <span class="overload">[1/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void cl::sycl::handler::experimental_depends_on </td>
<td>(</td>
<td class="paramtype"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1event.html">cl::sycl::event</a> </td>
<td class="paramname"><em>e</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Register a single event that this handler should wait for before running. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">e</td><td>The event that the handler should wait for before running. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a614cb2116ec4e92ca77d9b69b7a2f8ef" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a614cb2116ec4e92ca77d9b69b7a2f8ef">◆ </a></span>experimental_depends_on() <span class="overload">[2/2]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void cl::sycl::handler::experimental_depends_on </td>
<td>(</td>
<td class="paramtype">const std::vector&lt; <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1event.html">cl::sycl::event</a> &gt; &amp; </td>
<td class="paramname"><em>v</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Register a set of events that this handler should wait for before running. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">v</td><td>a vector of events. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="af61a453802ed627abe983fcd7b9024fd" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af61a453802ed627abe983fcd7b9024fd">◆ </a></span>experimental_prefetch()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void cl::sycl::handler::experimental_prefetch </td>
<td>(</td>
<td class="paramtype">const void * </td>
<td class="paramname"><em>ptr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>size</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Hints to the SYCL runtime that the data is available earlier than when the USM model would require it. </p>
<p>Can only be overlapped with kernel execution when Concurrent or System USM is available. </p><dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">ptr</td><td>Pointer to the memory to be prefetched to the device </td></tr>
<tr><td class="paramname">size</td><td>Number of bytes requested to be prefetched </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="ad360f52d93770802e350f10754f7ed6d" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad360f52d93770802e350f10754f7ed6d">◆ </a></span>fill() <span class="overload">[1/4]</span></h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TAcc , typename T , int dims, cl::sycl::access::mode accessMode, cl::sycl::access::target accessTarget, access::placeholder isPlaceholder, COMPUTECPP_ENABLE_IF(TAcc,(detail::can_copy_types&lt; T, TAcc &gt;::value &amp;&amp; detail::is_write_mode&lt; accessMode &gt;::value)) &gt; </div>
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void cl::sycl::handler::fill </td>
<td>(</td>
<td class="paramtype"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; TAcc, dims, accessMode, accessTarget, isPlaceholder &gt; </td>
<td class="paramname"><em>acc</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">T </td>
<td class="paramname"><em>val</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Fills the data associated with the accessor using the scalar value. </p>
<p>Special case of copy from host to device where the origin is a scalar value that will be replicated across the range of the accessor. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tr><td class="paramname">TAcc</td><td>Underlying type of the data associated with the accessor </td></tr>
<tr><td class="paramname">T</td><td>Underlying type of the host scalar </td></tr>
<tr><td class="paramname">dims</td><td>Number of dimensions of the accessor </td></tr>
<tr><td class="paramname">accessMode</td><td>Access mode of the accessor </td></tr>
<tr><td class="paramname">accessTarget</td><td>Access target of the accessor </td></tr>
<tr><td class="paramname">isPlaceholder</td><td>Whether the accessor is a placeholder </td></tr>
<tr><td class="paramname">COMPUTECPP_ENABLE_IF</td><td>The function is only valid when the access mode includes read access </td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">acc</td><td>Accessor with the data that will be filled </td></tr>
<tr><td class="paramname">val</td><td>Scalar used to fill the device data with </td></tr>
</table>
</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html#l01365">1365</a> of file <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html">apis.h</a>.</p>
</div>
</div>
<a id="a96f34754b90172152e6e68a8b76c0446" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96f34754b90172152e6e68a8b76c0446">◆ </a></span>fill() <span class="overload">[2/4]</span></h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void cl::sycl::handler::fill </td>
<td>(</td>
<td class="paramtype">void * </td>
<td class="paramname"><em>ptr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const T &amp; </td>
<td class="paramname"><em>pattern</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>count</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Fills the memory pointed by <code>ptr</code>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tr><td class="paramname">T</td><td>The type of the element. </td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">ptr</td><td>Pointer object to fill. </td></tr>
<tr><td class="paramname">pattern</td><td>The pattern to fill each element of <code>ptr</code> </td></tr>
<tr><td class="paramname">count</td><td>The number of elements of type T to fill. </td></tr>
</table>
</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html#l01402">1402</a> of file <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html">apis.h</a>.</p>
</div>
</div>
<a id="ae6d7565b85886156bf0a9e2b775472fb" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6d7565b85886156bf0a9e2b775472fb">◆ </a></span>fill() <span class="overload">[3/4]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void cl::sycl::handler::fill </td>
<td>(</td>
<td class="paramtype">const accessor_base &amp; </td>
<td class="paramname"><em>acc</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const void * </td>
<td class="paramname"><em>patternData</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const size_t </td>
<td class="paramname"><em>patternSize</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Fills the range of the accessor with value of hostScalarPtr[0]}. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">acc</td><td>Accessor with the data that will be filled </td></tr>
<tr><td class="paramname">patternData</td><td>Host data used to fill the device data with </td></tr>
<tr><td class="paramname">patternSize</td><td>Size of the host data </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="af3387bd5b8faaba3ed169d9fb45b8952" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3387bd5b8faaba3ed169d9fb45b8952">◆ </a></span>fill() <span class="overload">[4/4]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void cl::sycl::handler::fill </td>
<td>(</td>
<td class="paramtype">void * </td>
<td class="paramname"><em>ptr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const void * </td>
<td class="paramname"><em>patternData</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>patternSize</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>size</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Fills the memory pointed by <code>ptr</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">ptr</td><td>Pointer object to fill. </td></tr>
<tr><td class="paramname">patternData</td><td>Pointer to the memory that contains the pattern to use when filling <code>ptr</code>. </td></tr>
<tr><td class="paramname">patternSize</td><td>The size in bytes of the pattern. </td></tr>
<tr><td class="paramname">size</td><td>The number of bytes of <code>ptr</code> to fill with <code>patternData</code>. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="adaa9e1b9c31397bbfcb94a4161026326" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adaa9e1b9c31397bbfcb94a4161026326">◆ </a></span>get_context()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1context.html">context</a> cl::sycl::handler::get_context </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the current context for the command group. </p>
</div>
</div>
<a id="aaaff06d227e31e7f29d1968a52320321" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaff06d227e31e7f29d1968a52320321">◆ </a></span>get_device_weak()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">ddevice_wkptr cl::sycl::handler::get_device_weak </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns the current device for the command group. </p>
</div>
</div>
<a id="a783b418efd3c305647846dd1724c18ea" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a783b418efd3c305647846dd1724c18ea">◆ </a></span>get_kernel_bundle_program()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1program.html">program</a> cl::sycl::handler::get_kernel_bundle_program </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Get the program to use from a kernel bundle. </p>
<p><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#a66840e5d814dd97aa63121f3ce7012b1">has_kernel_bundle()</a> == true is a precondition. </p><dl><dt>Returns</dt><dd>A program. </dd></dl>
</div>
</div>
<a id="a51fc701fbd276e05ed83e48883542119" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51fc701fbd276e05ed83e48883542119">◆ </a></span>get_optimal_workgroup_size()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">detail::index_array cl::sycl::handler::get_optimal_workgroup_size </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1kernel.html">kernel</a> &amp; </td>
<td class="paramname"><em>syclKernel</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Gets the optimal workgroup size for the current device and the given kernel. </p>
<p>Internal implementation. </p><dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">syclKernel</td><td>Kernel to which we need to compute the workgroup size. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a66840e5d814dd97aa63121f3ce7012b1" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66840e5d814dd97aa63121f3ce7012b1">◆ </a></span>has_kernel_bundle()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">bool cl::sycl::handler::has_kernel_bundle </td>
<td>(</td>
<td class="paramname"></td><td>)</td>
<td> const</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Returns true if use_kernel_bundle(bundle) has been called with the handler. </p>
</div>
</div>
<a id="a2d31acb51ab89306691a73d9c188b21c" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d31acb51ab89306691a73d9c188b21c">◆ </a></span>interop_task_impl()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void cl::sycl::handler::interop_task_impl </td>
<td>(</td>
<td class="paramtype">const detail::interop_task_ptr &amp; </td>
<td class="paramname"><em>hostTaskCallable</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Schedules a host task with an interop_handle object. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">hostTaskCallable</td><td>Callable object that will be executed </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="adc2bc1950d746b68e457cc63c2998055" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc2bc1950d746b68e457cc63c2998055">◆ </a></span>memcpy()</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void cl::sycl::handler::memcpy </td>
<td>(</td>
<td class="paramtype">void * </td>
<td class="paramname"><em>dest</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const void * </td>
<td class="paramname"><em>src</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>size</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</div><div class="memdoc">
<p>Copies <code>count</code> bytes from <code>src</code> to . </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">dest</td><td>Pointer to the memory location to copy to. </td></tr>
<tr><td class="paramname">src</td><td>Pointer to the memory location to copy from. </td></tr>
<tr><td class="paramname">size</td><td>The number of bytes to copy. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a547a65572de8083252b465ac1074dc43" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a547a65572de8083252b465ac1074dc43">◆ </a></span>parallel_for() <span class="overload">[1/10]</span></h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimensions&gt; </div>
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void cl::sycl::handler::parallel_for </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1nd__range.html">nd_range</a>&lt; dimensions &gt; &amp; </td>
<td class="paramname"><em>ndRange</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1kernel.html">kernel</a> </td>
<td class="paramname"><em>syclKernel</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Parallel_for will enqueue the precompiled kernel syclKernel to be executed a number of instances working in parallel over the number of local and global work items specified by ndRange. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tr><td class="paramname">dimensions</td><td>Number of dimensions of the kernel </td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">ndRange</td><td>Dimensions of the global and local work groups </td></tr>
<tr><td class="paramname">syclKernel</td><td>The precompiled kernel to be enqueued </td></tr>
</table>
</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html#l00467">467</a> of file <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html">apis.h</a>.</p>
</div>
</div>
<a id="a4ccd2c8e4deeb2edf901710d711b256b" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ccd2c8e4deeb2edf901710d711b256b">◆ </a></span>parallel_for() <span class="overload">[2/10]</span></h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimensions&gt; </div>
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void cl::sycl::handler::parallel_for </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1range.html">range</a>&lt; dimensions &gt; &amp; </td>
<td class="paramname"><em>range</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1kernel.html">kernel</a> </td>
<td class="paramname"><em>syclKernel</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Parallel_for will enqueue the precompiled kernel syclKernel to be executed a number of instances working in parallel over the number of global work items specified by <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1range.html">range</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tr><td class="paramname">dimensions</td><td>Number of dimensions of the kernel </td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">range</td><td>Dimensions of the global work group </td></tr>
<tr><td class="paramname">syclKernel</td><td>The precompiled kernel to be enqueued </td></tr>
</table>
</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html#l00482">482</a> of file <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html">apis.h</a>.</p>
</div>
</div>
<a id="a4579e9fef96e51ab64ac1e5d9dc4d9b7" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4579e9fef96e51ab64ac1e5d9dc4d9b7">◆ </a></span>parallel_for() <span class="overload">[3/10]</span></h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimensions&gt; </div>
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void cl::sycl::handler::parallel_for </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1range.html">range</a>&lt; dimensions &gt; &amp; </td>
<td class="paramname"><em>range</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1id.html">id</a>&lt; dimensions &gt; </td>
<td class="paramname"><em>offset</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1kernel.html">kernel</a> </td>
<td class="paramname"><em>syclKernel</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Parallel_for will enqueue the precompiled kernel syclKernel to be executed a number of instances working in parallel over the number of global work items specified by <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1range.html">range</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tr><td class="paramname">dimensions</td><td>Number of dimensions of the kernel </td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">range</td><td>Dimensions of the global work group </td></tr>
<tr><td class="paramname">offset</td><td>The offset into the data being executed </td></tr>
<tr><td class="paramname">syclKernel</td><td>The precompiled kernel to be enqueued </td></tr>
</table>
</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html#l00499">499</a> of file <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html">apis.h</a>.</p>
</div>
</div>
<a id="ac69072e1239801448dadf86e1b8542fe" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac69072e1239801448dadf86e1b8542fe">◆ </a></span>parallel_for() <span class="overload">[4/10]</span></h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename nameT  = std::nullptr_t, typename functorT , int dimensions&gt; </div>
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void cl::sycl::handler::parallel_for </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1nd__range.html">nd_range</a>&lt; dimensions &gt; &amp; </td>
<td class="paramname"><em>ndRange</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const functorT &amp; </td>
<td class="paramname"><em>functor</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Parallel_for will enqueue the kernel <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl.html#afd8687e935d3df6c3fdbbc249e467d0d">functor</a> to be executed a number of instances working in parallel over the number of local and global work items specified by ndRange. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tr><td class="paramname">nameT</td><td>The name of the kernel being enqueued </td></tr>
<tr><td class="paramname">functorT</td><td>This is the type of the kernel. It will be automatically deduced by the compiler </td></tr>
<tr><td class="paramname">dimensions</td><td>Number of dimensions of the kernel </td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">ndRange</td><td>Dimensions of the global and local work groups </td></tr>
<tr><td class="paramname">functor</td><td>The kernel being enqueued </td></tr>
</table>
</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html#l00579">579</a> of file <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html">apis.h</a>.</p>
</div>
</div>
<a id="ae0e010b69b66eb87a78d0f0291e6f87a" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0e010b69b66eb87a78d0f0291e6f87a">◆ </a></span>parallel_for() <span class="overload">[5/10]</span></h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename nameT  = std::nullptr_t, typename functorT , int dimensions&gt; </div>
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void cl::sycl::handler::parallel_for </td>
<td>(</td>
<td class="paramtype"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1kernel.html">kernel</a> </td>
<td class="paramname"><em>syclKernel</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1nd__range.html">nd_range</a>&lt; dimensions &gt; &amp; </td>
<td class="paramname"><em>ndRange</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const functorT &amp; </td>
<td class="paramname"><em>functor</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Parallel_for will enqueue the kernel <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl.html#afd8687e935d3df6c3fdbbc249e467d0d">functor</a> to be executed a number of instances working in parallel over the number of local and global work items specified by ndRange. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tr><td class="paramname">nameT</td><td>The name of the kernel being enqueued </td></tr>
<tr><td class="paramname">functorT</td><td>This is the type of the kernel. It will be automatically deduced by the compiler </td></tr>
<tr><td class="paramname">dimensions</td><td>Number of dimensions of the kernel </td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">syclKernel</td><td>The precompiled kernel to be enqueued </td></tr>
<tr><td class="paramname">ndRange</td><td>Dimensions of the global and local work groups </td></tr>
<tr><td class="paramname">functor</td><td>The kernel being enqueued </td></tr>
</table>
</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html#l00601">601</a> of file <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html">apis.h</a>.</p>
</div>
</div>
<a id="a0914ce8c9f19a41918ab711d838b9d07" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0914ce8c9f19a41918ab711d838b9d07">◆ </a></span>parallel_for() <span class="overload">[6/10]</span></h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename nameT  = std::nullptr_t, typename functorT , int dimensions&gt; </div>
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void cl::sycl::handler::parallel_for </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1range.html">range</a>&lt; dimensions &gt; &amp; </td>
<td class="paramname"><em>range</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const functorT &amp; </td>
<td class="paramname"><em>functor</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Parallel_for will enqueue the kernel <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl.html#afd8687e935d3df6c3fdbbc249e467d0d">functor</a> to be executed a number of instances working in parallel over the number of global work items specified by <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1range.html">range</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tr><td class="paramname">nameT</td><td>The name of the kernel being enqueued </td></tr>
<tr><td class="paramname">functorT</td><td>This is the type of the kernel. It will be automatically deduced by the compiler </td></tr>
<tr><td class="paramname">dimensions</td><td>Number of dimensions of the kernel </td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">range</td><td>Dimensions of the global work group </td></tr>
<tr><td class="paramname">functor</td><td>The kernel being enqueued </td></tr>
</table>
</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html#l00755">755</a> of file <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html">apis.h</a>.</p>
</div>
</div>
<a id="a58ba5230da79a8c4e2fec90ed366c885" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58ba5230da79a8c4e2fec90ed366c885">◆ </a></span>parallel_for() <span class="overload">[7/10]</span></h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename nameT  = std::nullptr_t, typename functorT &gt; </div>
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void cl::sycl::handler::parallel_for </td>
<td>(</td>
<td class="paramtype">const size_t </td>
<td class="paramname"><em>range</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const functorT &amp; </td>
<td class="paramname"><em>functor</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Parallel_for will enqueue the kernel <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl.html#afd8687e935d3df6c3fdbbc249e467d0d">functor</a> to be executed a number of instances working in parallel over the number of global work items specified by <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1range.html">range</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tr><td class="paramname">nameT</td><td>The name of the kernel being enqueued </td></tr>
<tr><td class="paramname">functorT</td><td>This is the type of the kernel. It will be automatically deduced by the compiler </td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">range</td><td>Size of the global work group </td></tr>
<tr><td class="paramname">functor</td><td>The kernel being enqueued </td></tr>
</table>
</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html#l00773">773</a> of file <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html">apis.h</a>.</p>
</div>
</div>
<a id="aec471f48e98c26efe4de1c80069a82ac" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec471f48e98c26efe4de1c80069a82ac">◆ </a></span>parallel_for() <span class="overload">[8/10]</span></h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename nameT  = std::nullptr_t, typename functorT , int dimensions&gt; </div>
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void cl::sycl::handler::parallel_for </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1range.html">range</a>&lt; dimensions &gt; &amp; </td>
<td class="paramname"><em>range</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1id.html">id</a>&lt; dimensions &gt; &amp; </td>
<td class="paramname"><em>offset</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const functorT &amp; </td>
<td class="paramname"><em>functor</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Parallel_for will enqueue the kernel <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl.html#afd8687e935d3df6c3fdbbc249e467d0d">functor</a> to be executed a number of instances working in parallel over the number of global work items specified by <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1range.html">range</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tr><td class="paramname">nameT</td><td>The name of the kernel being enqueued </td></tr>
<tr><td class="paramname">functorT</td><td>This is the type of the kernel. It will be automatically deduced by the compiler </td></tr>
<tr><td class="paramname">dimensions</td><td>Number of dimensions of the kernel </td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">range</td><td>Dimensions of the global work group </td></tr>
<tr><td class="paramname">offset</td><td>The offset into the data being executed </td></tr>
<tr><td class="paramname">functor</td><td>The kernel being enqueued </td></tr>
</table>
</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html#l00794">794</a> of file <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html">apis.h</a>.</p>
</div>
</div>
<a id="ad026053d5411280844d6d8664abe9268" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad026053d5411280844d6d8664abe9268">◆ </a></span>parallel_for() <span class="overload">[9/10]</span></h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename nameT  = std::nullptr_t, typename functorT , int dimensions&gt; </div>
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void cl::sycl::handler::parallel_for </td>
<td>(</td>
<td class="paramtype"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1kernel.html">kernel</a> </td>
<td class="paramname"><em>syclKernel</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1range.html">range</a>&lt; dimensions &gt; &amp; </td>
<td class="paramname"><em>range</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const functorT &amp; </td>
<td class="paramname"><em>functor</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Parallel_for will enqueue the precompiled kernel syclKernel to be executed a number of instances working in parallel over the number of global work items specified by <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1range.html">range</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tr><td class="paramname">nameT</td><td>The name of the kernel being enqueued </td></tr>
<tr><td class="paramname">functorT</td><td>This is the type of the kernel. It will be automatically deduced by the compiler </td></tr>
<tr><td class="paramname">dimensions</td><td>Number of dimensions of the kernel </td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">syclKernel</td><td>The precompiled kernel which is being run </td></tr>
<tr><td class="paramname">range</td><td>Dimensions of the global work group </td></tr>
<tr><td class="paramname">functor</td><td>The kernel being enqueued </td></tr>
</table>
</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html#l00815">815</a> of file <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html">apis.h</a>.</p>
</div>
</div>
<a id="a4304deb0235543437d2026a9c4451929" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4304deb0235543437d2026a9c4451929">◆ </a></span>parallel_for() <span class="overload">[10/10]</span></h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename nameT  = std::nullptr_t, typename functorT , int dimensions&gt; </div>
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void cl::sycl::handler::parallel_for </td>
<td>(</td>
<td class="paramtype"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1kernel.html">kernel</a> </td>
<td class="paramname"><em>syclKernel</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1range.html">range</a>&lt; dimensions &gt; &amp; </td>
<td class="paramname"><em>range</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1id.html">id</a>&lt; dimensions &gt; &amp; </td>
<td class="paramname"><em>offset</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const functorT &amp; </td>
<td class="paramname"><em>functor</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Parallel_for will enqueue the precompiled kernel syclKernel to be executed a number of instances working in parallel over the number of global work items specified by <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1range.html">range</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tr><td class="paramname">nameT</td><td>The name of the kernel being enqueued </td></tr>
<tr><td class="paramname">functorT</td><td>This is the type of the kernel. It will be automatically deduced by the compiler </td></tr>
<tr><td class="paramname">dimensions</td><td>Number of dimensions of the kernel </td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">syclKernel</td><td>The precompiled kernel which is being run </td></tr>
<tr><td class="paramname">range</td><td>Dimensions of the global work group </td></tr>
<tr><td class="paramname">offset</td><td>The offset into the data being executed </td></tr>
<tr><td class="paramname">functor</td><td>The kernel being enqueued </td></tr>
</table>
</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html#l00838">838</a> of file <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html">apis.h</a>.</p>
</div>
</div>
<a id="ab77f0bc273b16ca90baeca132ffe2538" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab77f0bc273b16ca90baeca132ffe2538">◆ </a></span>parallel_for_work_group() <span class="overload">[1/5]</span></h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;int dimensions&gt; </div>
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void cl::sycl::handler::parallel_for_work_group </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1range.html">range</a>&lt; dimensions &gt; &amp; </td>
<td class="paramname"><em>numGroups</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1kernel.html">kernel</a> </td>
<td class="paramname"><em>syclKernel</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>parallel_for_work_group will enqueue the precompiled kernel syclKernel to be executed a number of instances working in parallel over the number of local and global work items specified by numGroups. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tr><td class="paramname">dimensions</td><td>Number of dimensions of the kernel </td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">numGroups</td><td>Dimensions of the global and local work groups </td></tr>
<tr><td class="paramname">syclKernel</td><td>The precompiled kernel which is being run </td></tr>
</table>
</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html#l00857">857</a> of file <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html">apis.h</a>.</p>
</div>
</div>
<a id="a635eddb1e72722967c0a40b2f723b3d2" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a635eddb1e72722967c0a40b2f723b3d2">◆ </a></span>parallel_for_work_group() <span class="overload">[2/5]</span></h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename nameT  = std::nullptr_t, typename functorT , int dimensions&gt; </div>
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void cl::sycl::handler::parallel_for_work_group </td>
<td>(</td>
<td class="paramtype"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1kernel.html">kernel</a> </td>
<td class="paramname"><em>syclKernel</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1range.html">range</a>&lt; dimensions &gt; &amp; </td>
<td class="paramname"><em>range</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const functorT &amp; </td>
<td class="paramname"><em>functor</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>parallel_for_work_group will enqueue the precompiled kernel syclKernel to be executed a number of instances working in parallel over the number of local and global work items specified by <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1range.html">range</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tr><td class="paramname">nameT</td><td>The name of the kernel being enqueued </td></tr>
<tr><td class="paramname">functorT</td><td>This is the type of the kernel. It will be automatically deduced by the compiler </td></tr>
<tr><td class="paramname">dimensions</td><td>Number of dimensions of the kernel </td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">syclKernel</td><td>The precompiled kernel which is being run </td></tr>
<tr><td class="paramname">range</td><td>Dimensions of the global work groups </td></tr>
<tr><td class="paramname">functor</td><td>The kernel being enqueued </td></tr>
</table>
</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html#l00975">975</a> of file <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html">apis.h</a>.</p>
</div>
</div>
<a id="ab7af811ef14f9e15c957f3abbfb8dc44" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7af811ef14f9e15c957f3abbfb8dc44">◆ </a></span>parallel_for_work_group() <span class="overload">[3/5]</span></h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename nameT  = std::nullptr_t, typename functorT , int dimensions&gt; </div>
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void cl::sycl::handler::parallel_for_work_group </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1range.html">range</a>&lt; dimensions &gt; &amp; </td>
<td class="paramname"><em>range</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const functorT &amp; </td>
<td class="paramname"><em>functor</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>parallel_for_work_group will enqueue the kernel <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl.html#afd8687e935d3df6c3fdbbc249e467d0d">functor</a> to be executed a number of instances working in parallel over the number of local and global work items specified by <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1range.html">range</a>. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tr><td class="paramname">nameT</td><td>The name of the kernel being enqueued </td></tr>
<tr><td class="paramname">functorT</td><td>This is the type of the kernel. It will be automatically deduced by the compiler </td></tr>
<tr><td class="paramname">dimensions</td><td>Number of dimensions of the kernel </td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">range</td><td>Dimensions of the global and local work groups </td></tr>
<tr><td class="paramname">functor</td><td>The kernel being enqueued </td></tr>
</table>
</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html#l00996">996</a> of file <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html">apis.h</a>.</p>
</div>
</div>
<a id="a8a5c5be38037f90b4d00c93ad32874d7" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a5c5be38037f90b4d00c93ad32874d7">◆ </a></span>parallel_for_work_group() <span class="overload">[4/5]</span></h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename nameT  = std::nullptr_t, typename functorT , int dimensions&gt; </div>
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void cl::sycl::handler::parallel_for_work_group </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1range.html">range</a>&lt; dimensions &gt; &amp; </td>
<td class="paramname"><em>numGroups</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1range.html">range</a>&lt; dimensions &gt; &amp; </td>
<td class="paramname"><em>groupSize</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const functorT &amp; </td>
<td class="paramname"><em>functor</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>parallel_for_work_group will enqueue the precompiled kernel syclKernel to be executed a number of instances working in parallel over the number of local and global work items specified by numGroups and groupSize. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tr><td class="paramname">functorT</td><td>This is the type of the kernel. It will be automatically deduced by the compiler </td></tr>
<tr><td class="paramname">dimensions</td><td>Number of dimensions of the kernel </td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">syclKernel</td><td>The precompiled kernel which is being run </td></tr>
<tr><td class="paramname">numGroups</td><td>dimensions of the work groups being launched </td></tr>
<tr><td class="paramname">groupSize</td><td>each work group will launch work-items of dimension of groupSize </td></tr>
</table>
</dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tr><td class="paramname">nameT</td><td>The name of the kernel being enqueued </td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">functor</td><td>The kernel being enqueued </td></tr>
</table>
</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html#l01019">1019</a> of file <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html">apis.h</a>.</p>
</div>
</div>
<a id="a59c4e92995e59422df1e2c8447bdba4f" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59c4e92995e59422df1e2c8447bdba4f">◆ </a></span>parallel_for_work_group() <span class="overload">[5/5]</span></h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename nameT  = std::nullptr_t, typename functorT , int dimensions&gt; </div>
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void cl::sycl::handler::parallel_for_work_group </td>
<td>(</td>
<td class="paramtype"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1kernel.html">kernel</a> </td>
<td class="paramname"><em>syclKernel</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1range.html">range</a>&lt; dimensions &gt; &amp; </td>
<td class="paramname"><em>numGroups</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1range.html">range</a>&lt; dimensions &gt; &amp; </td>
<td class="paramname"><em>groupSize</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const functorT &amp; </td>
<td class="paramname"><em>functor</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>parallel_for_work_group will enqueue the precompiled kernel syclKernel to be executed a number of instances working in parallel over the number of local and global work items specified by numGroups and groupSize. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tr><td class="paramname">nameT</td><td>The name of the kernel being enqueued </td></tr>
<tr><td class="paramname">functorT</td><td>This is the type of the kernel. It will be automatically deduced by the compiler </td></tr>
<tr><td class="paramname">dimensions</td><td>Number of dimensions of the kernel </td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">syclKernel</td><td>The precompiled kernel which is being run </td></tr>
<tr><td class="paramname">numGroups</td><td>dimensions of the work groups being launched </td></tr>
<tr><td class="paramname">groupSize</td><td>each work group will launch work-items of dimension of groupSize </td></tr>
<tr><td class="paramname">functor</td><td>The kernel being enqueued </td></tr>
</table>
</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html#l01044">1044</a> of file <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html">apis.h</a>.</p>
</div>
</div>
<a id="ad67a4a6023c01cb90f7f1357c8b66000" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad67a4a6023c01cb90f7f1357c8b66000">◆ </a></span>prefetch()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void cl::sycl::handler::prefetch </td>
<td>(</td>
<td class="paramtype">const void * </td>
<td class="paramname"><em>ptr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>size</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Hints to the SYCL runtime that the data is available earlier than when the USM model would require it. </p>
<p>Can only be overlapped with kernel execution when Concurrent or System USM is available. </p><dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">ptr</td><td>Pointer to the memory to be prefetched to the device </td></tr>
<tr><td class="paramname">size</td><td>Number of bytes requested to be prefetched </td></tr>
</table>
</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html#l01444">1444</a> of file <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html">apis.h</a>.</p>
</div>
</div>
<a id="a6b1595e93690c230e23da413f3d999ba" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b1595e93690c230e23da413f3d999ba">◆ </a></span>process_functor_arguments_impl()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void cl::sycl::handler::process_functor_arguments_impl </td>
<td>(</td>
<td class="paramtype"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1kernel.html">kernel</a> </td>
<td class="paramname"><em>syclKernel</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">detail::binary_address </td>
<td class="paramname"><em>functorBuffer</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const detail::functor_arg_descriptor &amp; </td>
<td class="paramname"><em>argDesc</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">detail::enqueue_device_kernel_command * </td>
<td class="paramname"><em>currentCommand</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Gets the parameters from a functor and sets them as OpenCL arguments. </p>
<p>Internal implementation. </p><dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">syclKernel</td><td>Kernel to which the functor is associated </td></tr>
<tr><td class="paramname">functorBuffer</td><td>Functor buffer casted down to a binary array </td></tr>
<tr><td class="paramname">SI</td><td>Kernel struct iterator </td></tr>
<tr><td class="paramname">SE</td><td>Kernel struct iterator </td></tr>
<tr><td class="paramname">OI</td><td>Kernel struct iterator </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a0d529c9e8d35ee704a1584ac76336889" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d529c9e8d35ee704a1584ac76336889">◆ </a></span>register_for_dma() <span class="overload">[1/3]</span></h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename elemT , int kDims, access::mode kMode, access::placeholder isPlaceholder&gt; </div>
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void cl::sycl::handler::register_for_dma </td>
<td>(</td>
<td class="paramtype"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; elemT, <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl.html#adee2e3bdfed43ffe0b7ef0ea737c5a4c">kDims</a>, <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl.html#af827bc05849ee05ae978679bca689c43">kMode</a>, <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/common_8h.html#a01c96dfd06d3493f3cec972d38f45156">COMPUTECPP_ACCESS_TARGET_DEVICE</a>, isPlaceholder &gt; &amp; </td>
<td class="paramname"><em>acc</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>stride</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Registers a global memory accessor for DMA transfer. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">acc</td><td>Accessor to use in a DMA transfer </td></tr>
<tr><td class="paramname">stride</td><td>DMA transfer stride, in number of elements </td></tr>
</table>
</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html#l01078">1078</a> of file <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html">apis.h</a>.</p>
</div>
</div>
<a id="a75f75115658c50f5a5398225241c1c76" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75f75115658c50f5a5398225241c1c76">◆ </a></span>register_for_dma() <span class="overload">[2/3]</span></h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename elemT , int kDims, access::placeholder isPlaceholder&gt; </div>
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void cl::sycl::handler::register_for_dma </td>
<td>(</td>
<td class="paramtype"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; elemT, <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl.html#adee2e3bdfed43ffe0b7ef0ea737c5a4c">kDims</a>, <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl_1_1access.html#ade7472cc9b6db9b3cd47fb9f3bc8c450aecae13117d6f0584c25a9da6c8f8415e">access::mode::read</a>, <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/common_8h.html#a01c96dfd06d3493f3cec972d38f45156">COMPUTECPP_ACCESS_TARGET_DEVICE</a>, isPlaceholder &gt; &amp; </td>
<td class="paramname"><em>acc</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>stride</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Registers a constant memory accessor for DMA transfer. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">acc</td><td>Accessor to use in a DMA transfer </td></tr>
<tr><td class="paramname">stride</td><td>DMA transfer stride, in number of elements </td></tr>
</table>
</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html#l01091">1091</a> of file <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html">apis.h</a>.</p>
</div>
</div>
<a id="ac3358a20e49c3510e7ec3b4e8728f483" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3358a20e49c3510e7ec3b4e8728f483">◆ </a></span>register_for_dma() <span class="overload">[3/3]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void cl::sycl::handler::register_for_dma </td>
<td>(</td>
<td class="paramtype">accessor_base &amp; </td>
<td class="paramname"><em>acc</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">size_t </td>
<td class="paramname"><em>strideBytes</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Registers an accessor for DMA transfer. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">acc</td><td>Accessor to use in a DMA transfer </td></tr>
<tr><td class="paramname">stride</td><td>DMA transfer stride, in bytes </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a953fb3a325258dc660a0c4f9bcce1a9f" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a953fb3a325258dc660a0c4f9bcce1a9f">◆ </a></span>require() <span class="overload">[1/3]</span></h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename elemT , int kDims, access::mode kMode, access::target kTarget, access::placeholder IsPlaceholder = access::placeholder::true_t&gt; </div>
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void cl::sycl::handler::require </td>
<td>(</td>
<td class="paramtype">const <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; elemT, <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl.html#adee2e3bdfed43ffe0b7ef0ea737c5a4c">kDims</a>, <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl.html#af827bc05849ee05ae978679bca689c43">kMode</a>, <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl.html#af98dc56956ad4fc67c4c52fdfa32f860">kTarget</a>, IsPlaceholder &gt; &amp; </td>
<td class="paramname"><em>acc</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Function that registers a placeholder accessor with the handler. </p>
<p>Defined in Codeplay Extension CP004. </p><dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">acc</td><td>Placeholder accessor </td></tr>
</table>
</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html#l01067">1067</a> of file <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html">apis.h</a>.</p>
</div>
</div>
<a id="a79909103961de6237c32643e43f57d13" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79909103961de6237c32643e43f57d13">◆ </a></span>require() <span class="overload">[2/3]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void cl::sycl::handler::require </td>
<td>(</td>
<td class="paramtype">const accessor_base &amp; </td>
<td class="paramname"><em>acc</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Internal function that registers a placeholder accessor with the handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">acc</td><td>Placeholder accessor </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a481be0c41842998c3593da40ef349df3" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a481be0c41842998c3593da40ef349df3">◆ </a></span>require() <span class="overload">[3/3]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void cl::sycl::handler::require </td>
<td>(</td>
<td class="paramtype">const accessor_base &amp; </td>
<td class="paramname"><em>acc</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">dmem_shptr </td>
<td class="paramname"><em>memObj</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl_1_1access.html#ade7472cc9b6db9b3cd47fb9f3bc8c450">access::mode</a> </td>
<td class="paramname"><em>mode</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl_1_1access.html#a6874ae9aff44c453a412c2adefb1b9f7">access::target</a> </td>
<td class="paramname"><em>target</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Internal function that registers a placeholder accessor with the handler. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">acc</td><td>Placeholder accessor </td></tr>
</table>
</dd>
</dl>
<dl class="deprecated"><dt><b><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/deprecated.html#_deprecated000008">Deprecated:</a></b></dt><dd>Bind the null accessor first, then call <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#a953fb3a325258dc660a0c4f9bcce1a9f">require()</a> </dd></dl>
</div>
</div>
<a id="ac6dc2ba0c93e4fe63c9ad7a7cfad6ec8" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6dc2ba0c93e4fe63c9ad7a7cfad6ec8">◆ </a></span>set_arg()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void cl::sycl::handler::set_arg </td>
<td>(</td>
<td class="paramtype">int </td>
<td class="paramname"><em>param_num</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">T &amp;&amp; </td>
<td class="paramname"><em>param</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Sets an argument when using interop kernels. </p>
<p class="definition">Definition at line <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html#l00356">356</a> of file <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html">apis.h</a>.</p>
</div>
</div>
<a id="a529b800f175828a7edc07b0d1a19a176" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a529b800f175828a7edc07b0d1a19a176">◆ </a></span>set_args()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void cl::sycl::handler::set_args </td>
<td>(</td>
<td class="paramtype">Ts &amp;&amp;... </td>
<td class="paramname"><em>args</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Set all the given kernel args arguments for an OpenCL kernel, as if <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#ac6dc2ba0c93e4fe63c9ad7a7cfad6ec8">set_arg()</a> was used with each of them in the same order and increasing index always starting at 0. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tr><td class="paramname">Ts</td><td>Types of the parameters passed to the OpenCL kernel </td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">args</td><td>Parameters passed to the OpenCL kernel </td></tr>
</table>
</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html#l00375">375</a> of file <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html">apis.h</a>.</p>
</div>
</div>
<a id="a753a7db9214d40fb8d43ac6c8b6833e2" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a753a7db9214d40fb8d43ac6c8b6833e2">◆ </a></span>single_task() <span class="overload">[1/3]</span></h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname">void cl::sycl::handler::single_task </td>
<td>(</td>
<td class="paramtype"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1kernel.html">kernel</a> </td>
<td class="paramname"><em>syclKernel</em></td><td>)</td>
<td></td>
</tr>
</table>
</div><div class="memdoc">
<p>This function effectively just launches a single thread to execute the kernel in serial asynchronously to the host execution. </p>
<p>This function takes in a precompiled kernel syclKernel previously created using build_with_kernel_type or compile_with_kernel_type </p><dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">syclKernel</td><td>The precompiled kernel to be enqueued </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a91585b4494de2792a5dce6bfcd416bf9" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91585b4494de2792a5dce6bfcd416bf9">◆ </a></span>single_task() <span class="overload">[2/3]</span></h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename nameT  = std::nullptr_t, typename functorT &gt; </div>
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void cl::sycl::handler::single_task </td>
<td>(</td>
<td class="paramtype">const functorT &amp; </td>
<td class="paramname"><em>functor</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>This function effectively just launches a single thread to execute the kernel in serial asynchronously to the host execution. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tr><td class="paramname">nameT</td><td>The name of the kernel being enqueued </td></tr>
<tr><td class="paramname">functorT</td><td>This is the type of the kernel. It will be automatically deduced by the compiler </td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">functor</td><td>The kernel being enqueued </td></tr>
</table>
</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html#l00430">430</a> of file <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html">apis.h</a>.</p>
</div>
</div>
<a id="a07d716116114414cd509a93ccd8dda33" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07d716116114414cd509a93ccd8dda33">◆ </a></span>single_task() <span class="overload">[3/3]</span></h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename nameT  = std::nullptr_t, typename functorT &gt; </div>
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void cl::sycl::handler::single_task </td>
<td>(</td>
<td class="paramtype"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1kernel.html">kernel</a> </td>
<td class="paramname"><em>syclKernel</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">const functorT &amp; </td>
<td class="paramname"><em>functor</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>This function effectively just launches a single thread to execute the kernel in serial asynchronously to the host execution. </p>
<p>This function takes in a precompiled kernel syclKernel previously created using build_with_kernel_type or compile_with_kernel_type </p><dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tr><td class="paramname">nameT</td><td>The name of the kernel being enqueued </td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">syclKernel</td><td>The precompiled kernel to be enqueued </td></tr>
</table>
</dd>
</dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tr><td class="paramname">functorT</td><td>This is the type of the kernel. It will be automatically deduced by the compiler </td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">functor</td><td>The kernel being enqueued </td></tr>
</table>
</dd>
</dl>
<p class="definition">Definition at line <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html#l00448">448</a> of file <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html">apis.h</a>.</p>
</div>
</div>
<a id="af5e3ae7393de2d7c830d48170ee0c989" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5e3ae7393de2d7c830d48170ee0c989">◆ </a></span>update_device_data()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void cl::sycl::handler::update_device_data </td>
<td>(</td>
<td class="paramtype">const accessor_base &amp; </td>
<td class="paramname"><em>acc</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl.html#a145741acbe1817e4b03338ffcfd21012">shared_ptr_class</a>&lt; void &gt; </td>
<td class="paramname"><em>hostPtr</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl_1_1access.html#ade7472cc9b6db9b3cd47fb9f3bc8c450">cl::sycl::access::mode</a> </td>
<td class="paramname"><em>accessMode</em>, </td>
</tr>
<tr>
<td class="paramkey"></td>
<td></td>
<td class="paramtype">bool </td>
<td class="paramname"><em>userProvidedPtr</em> </td>
</tr>
<tr>
<td></td>
<td>)</td>
<td></td><td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Updates device data by copying to/from the device. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">acc</td><td>Accessor that is used to access the buffer or image </td></tr>
<tr><td class="paramname">hostPtr</td><td>Pointer that points to data on the host </td></tr>
<tr><td class="paramname">accessMode</td><td>Operation indicator (read -&gt; copy_from_device, write -&gt; copy_to_device) </td></tr>
<tr><td class="paramname">userProvidedPtr</td><td>Indicated whether the host pointer was provided by the user or whether to use the internal one </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<a id="a7095e10bde4deca0f823ce471b734c42" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7095e10bde4deca0f823ce471b734c42">◆ </a></span>update_host()</h2>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , int dims, access::mode accessMode, access::target accessTarget, access::placeholder isPlaceholder&gt; </div>
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void cl::sycl::handler::update_host </td>
<td>(</td>
<td class="paramtype"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1accessor.html">accessor</a>&lt; T, dims, accessMode, accessTarget, isPlaceholder &gt; </td>
<td class="paramname"><em>acc</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Update the memory object accessed by a given accessor on the host. </p>
<p>The host copy of the memory object will be up to date once this has executed. </p><dl class="tparams"><dt>Template Parameters</dt><dd>
<table class="tparams">
<tr><td class="paramname">T</td><td>The accessor element type. </td></tr>
<tr><td class="paramname">dims</td><td>The accessor's dimensionality </td></tr>
<tr><td class="paramname">accessMode</td><td>The access mode of the accessor </td></tr>
<tr><td class="paramname">accessTarget</td><td>The access target. </td></tr>
<tr><td class="paramname">isPlaceholder</td><td>Is the accessor a placeholder? </td></tr>
</table>
</dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">acc</td><td>An accessor for the memory object to update. </td></tr>
</table>
</dd>
</dl>
<dl><dt>Note</dt><dd>This does not yet automatically update the host pointer given to the initial buffer. For this to be updated, construct the buffer using the property <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1property_1_1buffer_1_1use__host__ptr.html">property::buffer::use_host_ptr</a>. </dd></dl>
<p class="definition">Definition at line <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html#l01389">1389</a> of file <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html">apis.h</a>.</p>
</div>
</div>
<a id="a2431290ca2ef1df8cff33d8110a6f297" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2431290ca2ef1df8cff33d8110a6f297">◆ </a></span>update_host_impl()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void cl::sycl::handler::update_host_impl </td>
<td>(</td>
<td class="paramtype">const accessor_base &amp; </td>
<td class="paramname"><em>acc</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Implementation for update_host. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">acc</td><td>An accessor for the memory object to update. </td></tr>
</table>
</dd>
</dl>
<dl><dt>Note</dt><dd>This does not yet automatically update the host pointer given to the initial buffer. For this to be updated, construct the buffer using the property <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1property_1_1buffer_1_1use__host__ptr.html">property::buffer::use_host_ptr</a>. </dd></dl>
</div>
</div>
<a id="a4768d2e35307c5481d84c015b6f974e2" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4768d2e35307c5481d84c015b6f974e2">◆ </a></span>use_kernel_bundle_impl()</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">void cl::sycl::handler::use_kernel_bundle_impl </td>
<td>(</td>
<td class="paramtype">const dkernelbundle_shptr </td>
<td class="paramname"><em>execBundle</em></td><td>)</td>
<td></td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>This command group will use device images from the given kernel bundle when invoking kernels. </p>
<dl class="params"><dt>Parameters</dt><dd>
<table class="params">
<tr><td class="paramname">execBundle</td><td>The bundle to use kernels from. </td></tr>
</table>
</dd>
</dl>
</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aacaa7a26269cdb5e27ea8f221462580e" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacaa7a26269cdb5e27ea8f221462580e">◆ </a></span>acc</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl.html#adee2e3bdfed43ffe0b7ef0ea737c5a4c">kDims</a> const <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1accessor.html">accessor</a>&lt;elemT, <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl.html#adee2e3bdfed43ffe0b7ef0ea737c5a4c">kDims</a>, <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl.html#af827bc05849ee05ae978679bca689c43">kMode</a>, <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl.html#af98dc56956ad4fc67c4c52fdfa32f860">kTarget</a>, <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl_1_1access.html#af1c616691dbceeaca9cdd537a8ab0af9a1b756892a15e10bdbdfe033bf55e8d03">access::placeholder::true_t</a>&gt;&amp; cl::sycl::handler::acc</td>
</tr>
</table>
</div><div class="memdoc">
<b>Initial value:</b><pre class="highlight"><code class="fragment"><div class="line">{</div><div class="line">    this-&gt;<a class="code" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#a953fb3a325258dc660a0c4f9bcce1a9f">require</a>(static_cast&lt;const accessor_base&amp;&gt;(<a class="code" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#aacaa7a26269cdb5e27ea8f221462580e">acc</a>), <a class="code" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html#ab4bdf5d8c1017daf847d2113c11242f3">bufObj</a>.get_impl(),</div><div class="line"> <a class="code" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl.html#af827bc05849ee05ae978679bca689c43">kMode</a>, <a class="code" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl.html#af98dc56956ad4fc67c4c52fdfa32f860">kTarget</a>)</div></code></pre><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html#l01114">1114</a> of file <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html">apis.h</a>.</p>
</div>
</div>
<a id="ab4bdf5d8c1017daf847d2113c11242f3" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4bdf5d8c1017daf847d2113c11242f3">◆ </a></span>bufObj</h2>
<div class="memitem">
<div class="memproto">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl.html#adee2e3bdfed43ffe0b7ef0ea737c5a4c">kDims</a>&amp; cl::sycl::handler::bufObj</td>
</tr>
</table>
</div><div class="memdoc">
<p class="definition">Definition at line <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html#l01112">1112</a> of file <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html">apis.h</a>.</p>
</div>
</div>
<a id="aca8ae9b682242271c828237b136d2646" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca8ae9b682242271c828237b136d2646">◆ </a></span>m_fallbackQueue</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">dqueue_shptr cl::sycl::handler::m_fallbackQueue</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Pointer to the fallback queue (if any) </p>
<p class="definition">Definition at line <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html#l01661">1661</a> of file <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html">apis.h</a>.</p>
</div>
</div>
<a id="ac7bffc7ce382906014d6cfaafb7c75e9" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7bffc7ce382906014d6cfaafb7c75e9">◆ </a></span>m_numKernels</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">unsigned cl::sycl::handler::m_numKernels</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Number of kernels in the command group. </p>
<p class="definition">Definition at line <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html#l01671">1671</a> of file <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html">apis.h</a>.</p>
</div>
</div>
<a id="a3d6d146a3f005c5a27e653a5dab16550" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d6d146a3f005c5a27e653a5dab16550">◆ </a></span>m_paramVec</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname"><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/namespacecl_1_1sycl.html#a0a3b58674c77d248758b6bee05800ac5">vector_class</a>&lt;add_param_func_t&gt; cl::sycl::handler::m_paramVec</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p class="definition">Definition at line <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html#l01667">1667</a> of file <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html">apis.h</a>.</p>
</div>
</div>
<a id="a53746faca0e6189185ff0218bbda5f22" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53746faca0e6189185ff0218bbda5f22">◆ </a></span>m_queue</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">dqueue_shptr cl::sycl::handler::m_queue</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Queue to which this handler was submitted to. </p>
<p class="definition">Definition at line <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html#l01657">1657</a> of file <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html">apis.h</a>.</p>
</div>
</div>
<a id="a65cd7a5b02ea526bb946eff87188afa1" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65cd7a5b02ea526bb946eff87188afa1">◆ </a></span>m_trans</h2>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
<tr>
<td class="mlabels-left">
<table class="memname">
<tr>
<td class="memname">dtrans_uptr cl::sycl::handler::m_trans</td>
</tr>
</table>
</td>
<td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span> </td>
</tr>
</table>
</div><div class="memdoc">
<p>Internal transaction associated with the handler. </p>
<p class="definition">Definition at line <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html#l01653">1653</a> of file <a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html">apis.h</a>.</p>
</div>
</div>
<hr>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="http://127.0.0.1/products/computecpp/ce/2.11.0/api-reference/apis_8h_source.html">apis.h</a></li>
</ul>
</div></body>
<!-- Mirrored from 127.0.0.1/products/computecpp/ce/2.11.0/api-reference/classcl_1_1sycl_1_1handler.html by HTTrack Website Copier/3.x [XR&CO'2014], Mon, 22 Sep 2025 18:52:46 GMT -->
</html>
                    <a id="bottom"></a>
                </div>
            </article>

            <!-- Separator -->
            <div class="separator"></div>

            <!-- Footer Target -->
            <div id="footer-target"></div>
        </div>
    </div>
</div>
<!-- Handle layout resizing here to avoid jumping -->
<script nonce="0319ed3c5cd262987189b360154f8d55">
    const resizerCookie = getCookie('CDPRESIZER');
    if (resizerCookie) {
        const cookieValue = JSON.parse(resizerCookie);

        for (let [key, value] of Object.entries(cookieValue)) {
            if (value === null || value === undefined) {
                continue;
            }

            key = atob(key);
            $(':root')[0].style.setProperty('--' + key, value + 'px');
        }
    }
</script>

</main>

<!-- Product Selector-->
<div id="productSelectorDialog" class="popupDialog">
    <div class="side-by-side-panel panel">
        <div id="products">
            <div>
                <h1>Select a Product</h1>
            </div>
            <ul>
                <li>
                    <a class="productSelection oneapi" data-product="oneapi">
                        oneAPI
                    </a>
                </li>
            </ul>
        </div>
        <div id="product-selection">
            <div id="no-product">
                Please select a product
            </div>
            <div id="product">
                <div id="product-oneapi" class="product-view">
                    <h1>

                        oneAPI
                    </h1>
                    <p>oneAPI is a cross-industry, open, standards-based unified programming model that delivers a common developer experience across accelerator architecture - for faster application performance, more productivity, and greater innovation.</p>
                    <ul id="variants">
                        <li>
                            <a href="http://127.0.0.1/products/oneapi/construction-kit/">
                                <div>
                                    Construction Kit
                                </div>
                                <div>
                                    <i class="material-icons">arrow_right</i>
                                </div>
                            </a>
                        </li>
                        <li>
                            <a href="http://127.0.0.1/products/oneapi/amd/">
                                <div>
                                    for AMD GPU
                                </div>
                                <div>
                                    <i class="material-icons">arrow_right</i>
                                </div>
                            </a>
                        </li>
                        <li>
                            <a href="http://127.0.0.1/products/oneapi/nvidia/">
                                <div>
                                    for NVIDIA® GPUs
                                </div>
                                <div>
                                    <i class="material-icons">arrow_right</i>
                                </div>
                            </a>
                        </li>
                    </ul>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Color Scheme Selector-->
<div id="colorSchemeDialog" class="popupDialog">
    <div>
        <div class="selectDarkMode">
            <div>
                <img src="http://127.0.0.1/assets/img/darkmode.png" alt="Dark Mode" />
            </div>
            <div>
                <i class="material-icons">brightness_2</i>
                <h1>Dark Mode</h1>
                <p>Light text on a dark background.</p>
            </div>
        </div>
        <div class="selectLightMode">
            <div>
                <img src="http://127.0.0.1/assets/img/lightmode.png" alt="Light Mode" />
            </div>
            <div>
                <i class="material-icons">lightbulb_outline</i>
                <h1>Light Mode</h1>
                <p>Dark text on a light background.</p>
            </div>
        </div>
    </div>
</div>

<!-- Site Selector -->
<div id="siteSelectorDialog" class="popupDialog">
    <div class="panel" id="profile-panel">
        <header>
            <div>
                <i class="material-icons">public</i>
            </div>
            <div>
                <h1>Also,</h1>
                <h2>part of our network</h2>
            </div>
        </header>
        <ul>
            <li>
                <a href="https://www.codeplay.com/" target="_blank" rel="nofollow noopener noreferrer">
                    <h1>Codeplay.com</h1>
                    <p>Find out about Codeplay, the latest company news and blog posts.</p>
                </a>
            </li>
            <li>
                <a href="https://www.sycl.tech/" target="_blank" rel="nofollow noopener noreferrer">
                    <h1>SYCL.tech</h1>
                    <p>Find out about the latest SYCL news, videos and projects.</p>
                </a>
            </li>
            <li class="selected">
                <a>
                    <img src="http://127.0.0.1/assets/img/you-are-here.png" alt="You Are Here Logo" />
                    <h1>Codeplay Developer</h1>
                    <p>Get the latest documentation and release packages for ComputeCpp and ComputeSuite</p>
                </a>
            </li>
            <li>
                <a href="https://github.com/codeplaysoftware" target="_blank" rel="nofollow noopener noreferrer">
                    <h1>Codeplay Open Source</h1>
                    <p>Browse our open source projects and frameworks on GitHub.</p>
                </a>
            </li>
        </ul>
    </div>
</div>

<!-- Footer section -->
<footer class="section-padding">
    <div class="content-wrapper">
        <div>
            <h1>&copy; Codeplay Software Ltd</h1>
            <div id="copyright"></div>
        </div>
        <div>
            <ul>
                <li><a href="https://codeplay.com/" target="_blank" rel="noopener">
                    Visit codeplay.com</a></li>
                <li><a href="https://codeplay.com/company/privacy/" target="_blank" rel="noopener">
                    View Our Privacy Policy</a></li>
                <li><a href="http://127.0.0.1/cookies/">
                    Read Our Cookie Policy</a></li>
            </ul>
        </div>
    </div>
</footer>

</body>
</html>